<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (version 1.7.0-google-v6) on Thu Apr 16 08:46:53 PDT 2015 -->
<title>Treebank (Dan Bikel's Parsing Engine)</title>
<meta name="date" content="2015-04-16">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Treebank (Dan Bikel\'s Parsing Engine)";
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Treebank.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
<div class="aboutLanguage"><em>Parsing Engine</em></div>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../danbikel/parser/Transition.html" title="class in danbikel.parser"><span class="strong">Prev Class</span></a></li>
<li><a href="../../danbikel/parser/Word.html" title="class in danbikel.parser"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?danbikel/parser/Treebank.html" target="_top">Frames</a></li>
<li><a href="Treebank.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">danbikel.parser</div>
<h2 title="Interface Treebank" class="title">Interface Treebank</h2>
</div>
<div class="contentContainer">
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Known Implementing Classes:</dt>
<dd><a href="../../danbikel/parser/lang/AbstractTreebank.html" title="class in danbikel.parser.lang">AbstractTreebank</a>, <a href="../../danbikel/parser/english/BrokenTreebank.html" title="class in danbikel.parser.english">BrokenTreebank</a>, <a href="../../danbikel/parser/arabic/Treebank.html" title="class in danbikel.parser.arabic">Treebank</a>, <a href="../../danbikel/parser/chinese/Treebank.html" title="class in danbikel.parser.chinese">Treebank</a>, <a href="../../danbikel/parser/english/Treebank.html" title="class in danbikel.parser.english">Treebank</a></dd>
</dl>
<hr>
<br>
<pre>public interface <span class="strong">Treebank</span></pre>
<div class="block">A <code>Treebank</code> implementation provides data and methods specific
 to the structures found in a particular Treebank.
 <p>
 A language package must provide an implementation of this interface.</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../danbikel/parser/Treebank.html#addAugmentation(danbikel.parser.Nonterminal,%20danbikel.lisp.Symbol)">addAugmentation</a></strong>(<a href="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</a>&nbsp;nonterminal,
               <a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;augmentation)</code>
<div class="block">Adds the specified augmentation to the end of the (possibly empty)
 augmentation list of the specified <code>Nonterminal</code> object.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a></code></td>
<td class="colLast"><code><strong><a href="../../danbikel/parser/Treebank.html#augmentationDelimiters()">augmentationDelimiters</a></strong>()</code>
<div class="block">Returns a string whose characters are the set of delimiters for complex
 nonterminal labels.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a></code></td>
<td class="colLast"><code><strong><a href="../../danbikel/parser/Treebank.html#baseNPLabel()">baseNPLabel</a></strong>()</code>
<div class="block">Returns the symbol with which <a href="../../danbikel/parser/Training.html#addBaseNPs(danbikel.lisp.Sexp)"><code>Training.addBaseNPs(Sexp)</code></a> will
 relabel core NPs.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>char</code></td>
<td class="colLast"><code><strong><a href="../../danbikel/parser/Treebank.html#canonicalAugDelimiter()">canonicalAugDelimiter</a></strong>()</code>
<div class="block">Returns the first character of the string returned by
 <a href="../../danbikel/parser/Treebank.html#augmentationDelimiters()"><code>augmentationDelimiters()</code></a>, which will be considered the
 &quot;canonical&quot; augmentation delimiter when adding
 new augmentations, such as the argument augmentations added by
 implementations of <a href="../../danbikel/parser/Training.html#identifyArguments(danbikel.lisp.Sexp)"><code>Training.identifyArguments(Sexp)</code></a>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a></code></td>
<td class="colLast"><code><strong><a href="../../danbikel/parser/Treebank.html#constructPreterminal(danbikel.parser.Word)">constructPreterminal</a></strong>(<a href="../../danbikel/parser/Word.html" title="class in danbikel.parser">Word</a>&nbsp;word)</code>
<div class="block">Converts a <a href="../../danbikel/parser/Word.html" title="class in danbikel.parser"><code>Word</code></a> object into a preterminal subtree.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../danbikel/parser/Treebank.html#containsAugmentation(danbikel.lisp.Symbol,%20danbikel.lisp.Symbol)">containsAugmentation</a></strong>(<a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;nonterminal,
                    <a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;augmentation)</code>
<div class="block">Provides an efficient, thread-safe method for testing whether the
 specified nonterminal contains the specified augmentation (without
 parsing the nonterminal).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../danbikel/parser/Treebank.html#defaultParseNonterminal(danbikel.lisp.Symbol,%20danbikel.parser.Nonterminal)">defaultParseNonterminal</a></strong>(<a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label,
                       <a href="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</a>&nbsp;nonterminal)</code>
<div class="block">Fills in the specified <code>Nonterminal</code> object to represent
 all the components of a complex nonterminal annotation: the base label,
 any augmentations and any index.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a></code></td>
<td class="colLast"><code><strong><a href="../../danbikel/parser/Treebank.html#getCanonical(danbikel.lisp.Symbol)">getCanonical</a></strong>(<a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label)</code>
<div class="block">Returns a canonical version of the specified nonterminal label; if
 <code>label</code> already is in canonical form, it is returned.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a></code></td>
<td class="colLast"><code><strong><a href="../../danbikel/parser/Treebank.html#getCanonical(danbikel.lisp.Symbol,%20boolean)">getCanonical</a></strong>(<a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label,
            boolean&nbsp;stripAugmentations)</code>
<div class="block">Returns a canonical version of the specified nonterminal label; if
 <code>label</code> already is in canonical form, it is returned.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a></code></td>
<td class="colLast"><code><strong><a href="../../danbikel/parser/Treebank.html#getTag(danbikel.lisp.Sexp)">getTag</a></strong>(<a href="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;preterminal)</code>
<div class="block">Gets the component of the preterminal tree that corresponds to the
 part of speech tag.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../danbikel/parser/Treebank.html#getTraceIndex(danbikel.lisp.Sexp,%20danbikel.parser.Nonterminal)">getTraceIndex</a></strong>(<a href="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;preterm,
             <a href="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</a>&nbsp;nonterminal)</code>
<div class="block">Returns the index of a trace for the specified null element preterminal.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../danbikel/parser/Treebank.html#isAugDelim(danbikel.lisp.Sexp)">isAugDelim</a></strong>(<a href="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;sexp)</code>
<div class="block">Returns whether the specified S-expression is a symbol that is an
 augmentation delimiter for a complex nonterminal label.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../danbikel/parser/Treebank.html#isBaseNP(danbikel.lisp.Symbol)">isBaseNP</a></strong>(<a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label)</code>
<div class="block">Returns whether the specified label is for a base NP.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../danbikel/parser/Treebank.html#isComma(danbikel.lisp.Symbol)">isComma</a></strong>(<a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;word)</code>
<div class="block">Returns <code>true</code> if the specified word is a comma.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../danbikel/parser/Treebank.html#isConjunction(danbikel.lisp.Symbol)">isConjunction</a></strong>(<a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label)</code>
<div class="block">Returns <code>true</code> if the canonical version of the specified label
 is a conjunction tag or nonterminal in a particular Treebank.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../danbikel/parser/Treebank.html#isLeftParen(danbikel.lisp.Symbol)">isLeftParen</a></strong>(<a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;word)</code>
<div class="block">Returns <code>true</code> if the specified word is a left
 parenthesis.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../danbikel/parser/Treebank.html#isNP(danbikel.lisp.Symbol)">isNP</a></strong>(<a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label)</code>
<div class="block">Returns <code>true</code> if the canonical version of the specified label
 is an NP for the current language's Treebank.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../danbikel/parser/Treebank.html#isNullElementPreterminal(danbikel.lisp.Sexp)">isNullElementPreterminal</a></strong>(<a href="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</code>
<div class="block">Returns <code>true</code> if the specified S-expression represents
 a preterminal whose terminal element is the null element for the current
 language's Treebank.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../danbikel/parser/Treebank.html#isPossessivePreterminal(danbikel.lisp.Sexp)">isPossessivePreterminal</a></strong>(<a href="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</code>
<div class="block">Returns <code>true</code> if the specified S-expression represents
 a preterminal that is the possessive part of speech.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../danbikel/parser/Treebank.html#isPreterminal(danbikel.lisp.Sexp)">isPreterminal</a></strong>(<a href="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</code>
<div class="block">Returns whether <code>tree</code> represents a preterminal subtree in the
 parse trees for this language's Treebank.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../danbikel/parser/Treebank.html#isPuncToRaise(danbikel.lisp.Sexp)">isPuncToRaise</a></strong>(<a href="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;preterm)</code>
<div class="block">Returns <code>true</code> if the specified S-expression represents
 a preterminal and a part-of-speech tag that indicates punctuation
 to be raised when running <a href="../../danbikel/parser/Training.html#raisePunctuation(danbikel.lisp.Sexp)"><code>Training.raisePunctuation(Sexp)</code></a>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../danbikel/parser/Treebank.html#isPunctuation(danbikel.lisp.Symbol)">isPunctuation</a></strong>(<a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;tag)</code>
<div class="block">Returns <code>true</code> if the specified part of speech tag is one
 for which <a href="../../danbikel/parser/Treebank.html#isPuncToRaise(danbikel.lisp.Sexp)"><code>isPuncToRaise(Sexp)</code></a> would return <code>true</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../danbikel/parser/Treebank.html#isRightParen(danbikel.lisp.Symbol)">isRightParen</a></strong>(<a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;word)</code>
<div class="block">Returns <code>true</code> if the specified word is a right
 parenthesis.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../danbikel/parser/Treebank.html#isSentence(danbikel.lisp.Symbol)">isSentence</a></strong>(<a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label)</code>
<div class="block">Returns <code>true</code> is the specified nonterminal label represents a
 sentence in the current language's Treebank.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../danbikel/parser/Treebank.html#isVerb(danbikel.lisp.Sexp)">isVerb</a></strong>(<a href="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;preterminal)</code>
<div class="block">Returns <code>true</code> if the specified preterminal is that of a verb.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../danbikel/parser/Treebank.html#isVerbTag(danbikel.lisp.Symbol)">isVerbTag</a></strong>(<a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;tag)</code>
<div class="block">Returns <code>true</code> if the specified symbol is the part of speech
 tag of a verb.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../danbikel/parser/Treebank.html#isWHNP(danbikel.lisp.Symbol)">isWHNP</a></strong>(<a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label)</code>
<div class="block">Returns <code>true</code> if the canonical version of the specified label
 is an NP that undergoes WH-movement in a particular Treebank.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../danbikel/parser/Word.html" title="class in danbikel.parser">Word</a></code></td>
<td class="colLast"><code><strong><a href="../../danbikel/parser/Treebank.html#makeWord(danbikel.lisp.Sexp)">makeWord</a></strong>(<a href="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;preterminal)</code>
<div class="block">Constructs a <code>Word</code> object from the specified preterminal
 subtree.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>char</code></td>
<td class="colLast"><code><strong><a href="../../danbikel/parser/Treebank.html#nonTreebankDelimiter()">nonTreebankDelimiter</a></strong>()</code>
<div class="block">Returns a delimiter not already in use by the current treebank, for use
 when constructing lexicalized nonterminals when the <a href="../../danbikel/parser/Settings.html#decoderOutputHeadLexicalizedLabels"><code>Settings.decoderOutputHeadLexicalizedLabels</code></a> is <tt>true</tt>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>char</code></td>
<td class="colLast"><code><strong><a href="../../danbikel/parser/Treebank.html#nonTreebankLeftBracket()">nonTreebankLeftBracket</a></strong>()</code>
<div class="block">Returns a left-bracket character that is not an existing metacharacter
 in the current treebank, for use when the
 <a href="../../danbikel/parser/Settings.html#decoderOutputHeadLexicalizedLabels"><code>Settings.decoderOutputHeadLexicalizedLabels</code></a> is <tt>true</tt>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>char</code></td>
<td class="colLast"><code><strong><a href="../../danbikel/parser/Treebank.html#nonTreebankRightBracket()">nonTreebankRightBracket</a></strong>()</code>
<div class="block">Returns a right-bracket character that is not an existing metacharacter in
 the current treebank, for use when constructing lexicalized nonterminals
 when the <a href="../../danbikel/parser/Settings.html#decoderOutputHeadLexicalizedLabels"><code>Settings.decoderOutputHeadLexicalizedLabels</code></a> is
 <tt>true</tt>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a></code></td>
<td class="colLast"><code><strong><a href="../../danbikel/parser/Treebank.html#NPLabel()">NPLabel</a></strong>()</code>
<div class="block">Returns the symbol that <a href="../../danbikel/parser/Training.html#addBaseNPs(danbikel.lisp.Sexp)"><code>Training.addBaseNPs(Sexp)</code></a> should
 add as a parent if a base NP is not dominated by an NP.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</a></code></td>
<td class="colLast"><code><strong><a href="../../danbikel/parser/Treebank.html#parseNonterminal(danbikel.lisp.Symbol)">parseNonterminal</a></strong>(<a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label)</code>
<div class="block">Returns a <code>Nonterminal</code> object to represent all the
 components of a complex nonterminal annotation: the base label, any
 augmentations and any index.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</a></code></td>
<td class="colLast"><code><strong><a href="../../danbikel/parser/Treebank.html#parseNonterminal(danbikel.lisp.Symbol,%20danbikel.parser.Nonterminal)">parseNonterminal</a></strong>(<a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label,
                <a href="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</a>&nbsp;nonterminal)</code>
<div class="block">Identical to <a href="../../danbikel/parser/Treebank.html#parseNonterminal(danbikel.lisp.Symbol)"><code>parseNonterminal(Symbol)</code></a>, except that instead of
 returning a newly-created <code>Nonterminal</code> object, this
 method merely modifies the specified <code>Nonterminal</code> object.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../danbikel/parser/Treebank.html#removeAugmentation(danbikel.parser.Nonterminal,%20danbikel.lisp.Symbol)">removeAugmentation</a></strong>(<a href="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</a>&nbsp;nonterminal,
                  <a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;augmentation)</code>
<div class="block">Removes the specified augmentation from the augmentation list of the
 specified <code>Nonterminal</code> object, and the previous augmentation
 delimiter.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a></code></td>
<td class="colLast"><code><strong><a href="../../danbikel/parser/Treebank.html#removeAugmentation(danbikel.lisp.Sexp,%20danbikel.parser.Nonterminal,%20danbikel.lisp.Symbol)">removeAugmentation</a></strong>(<a href="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;sexp,
                  <a href="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</a>&nbsp;nonterminal,
                  <a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;augmentation)</code>
<div class="block">Removes the specified nonterminal augmentation from the specified
 S-expression, using the specified <a href="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser"><code>Nonterminal</code></a> object for temporary
 storage.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a></code></td>
<td class="colLast"><code><strong><a href="../../danbikel/parser/Treebank.html#sentenceLabel()">sentenceLabel</a></strong>()</code>
<div class="block">Returns the canonical label for a sentence, for de-transforming sentences
 that were transformed via <a href="../../danbikel/parser/Training.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)"><code>Training.relabelSubjectlessSentences(Sexp)</code></a>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a></code></td>
<td class="colLast"><code><strong><a href="../../danbikel/parser/Treebank.html#stripAllButIndex(danbikel.lisp.Symbol)">stripAllButIndex</a></strong>(<a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label)</code>
<div class="block">Returns a symbol identical to the specified <code>label</code>, except
 all augmentations other than the index will be removed.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a></code></td>
<td class="colLast"><code><strong><a href="../../danbikel/parser/Treebank.html#stripAllButIndex(danbikel.lisp.Symbol,%20danbikel.parser.Nonterminal)">stripAllButIndex</a></strong>(<a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label,
                <a href="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</a>&nbsp;nonterminal)</code>
<div class="block">Identical to <a href="../../danbikel/parser/Treebank.html#stripAllButIndex(danbikel.lisp.Symbol)"><code>stripAllButIndex(Symbol)</code></a>, except that instead of
 creating a new <code>Nonterminal</code> object for use by
 <a href="../../danbikel/parser/Treebank.html#parseNonterminal(danbikel.lisp.Symbol,%20danbikel.parser.Nonterminal)"><code>parseNonterminal(Symbol,Nonterminal)</code></a>, this method
 uses the specified <code>nonterminal</code> object.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a></code></td>
<td class="colLast"><code><strong><a href="../../danbikel/parser/Treebank.html#stripAugmentation(danbikel.lisp.Symbol)">stripAugmentation</a></strong>(<a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label)</code>
<div class="block">Returns the <code>Symbol</code> created by stripping off all
 augmentations, that is all characters after and including the first
 character that appears in the string returned by
 <a href="../../danbikel/parser/Treebank.html#augmentationDelimiters()"><code>augmentationDelimiters()</code></a>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a></code></td>
<td class="colLast"><code><strong><a href="../../danbikel/parser/Treebank.html#stripIndex(danbikel.lisp.Symbol)">stripIndex</a></strong>(<a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label)</code>
<div class="block">Returns <code>label</code>, but stripped of any index augmentation.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a></code></td>
<td class="colLast"><code><strong><a href="../../danbikel/parser/Treebank.html#stripIndex(danbikel.lisp.Symbol,%20danbikel.parser.Nonterminal)">stripIndex</a></strong>(<a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label,
          <a href="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</a>&nbsp;nonterminal)</code>
<div class="block">Identical to <a href="../../danbikel/parser/Treebank.html#stripIndex(danbikel.lisp.Symbol)"><code>stripIndex(Symbol)</code></a>, except that instead of creating
 a new <code>Nonterminal</code> object for use by <a href="../../danbikel/parser/Treebank.html#parseNonterminal(danbikel.lisp.Symbol,%20danbikel.parser.Nonterminal)"><code>parseNonterminal(Symbol,Nonterminal)</code></a>, this method simply passes the
 specified <code>nonterminal</code> object.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a></code></td>
<td class="colLast"><code><strong><a href="../../danbikel/parser/Treebank.html#subjectAugmentation()">subjectAugmentation</a></strong>()</code>
<div class="block">Returns the symbol that is used to augment nonterminals to indicate matrix
 subjects in the current language's Treebank.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a></code></td>
<td class="colLast"><code><strong><a href="../../danbikel/parser/Treebank.html#subjectlessSentenceLabel()">subjectlessSentenceLabel</a></strong>()</code>
<div class="block">Returns the symbol with which <a href="../../danbikel/parser/Training.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)"><code>Training.relabelSubjectlessSentences(Sexp)</code></a>
 will relabel sentences when they have no subjects.</div>
</td>
</tr>
</table>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="isPreterminal(danbikel.lisp.Sexp)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isPreterminal</h4>
<pre>boolean&nbsp;isPreterminal(<a href="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</pre>
<div class="block">Returns whether <code>tree</code> represents a preterminal subtree in the
 parse trees for this language's Treebank.  Typically, preterminals are
 part-of-speech tags.</div>
</li>
</ul>
<a name="getTag(danbikel.lisp.Sexp)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getTag</h4>
<pre><a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;getTag(<a href="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;preterminal)</pre>
<div class="block">Gets the component of the preterminal tree that corresponds to the
 part of speech tag.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>preterminal</code> - a tree that is assumed to be a preterminal</dd>
<dt><span class="strong">Returns:</span></dt><dd>the symbol in <code>preterminal</code> that is a part of speech</dd></dl>
</li>
</ul>
<a name="makeWord(danbikel.lisp.Sexp)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>makeWord</h4>
<pre><a href="../../danbikel/parser/Word.html" title="class in danbikel.parser">Word</a>&nbsp;makeWord(<a href="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;preterminal)</pre>
<div class="block">Constructs a <code>Word</code> object from the specified preterminal
 subtree.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>preterminal</code> - a tree that is assumed to be a preterminal</dd>
<dt><span class="strong">Returns:</span></dt><dd>the symbol in <code>preterminal</code> that is a part of speech</dd></dl>
</li>
</ul>
<a name="constructPreterminal(danbikel.parser.Word)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>constructPreterminal</h4>
<pre><a href="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;constructPreterminal(<a href="../../danbikel/parser/Word.html" title="class in danbikel.parser">Word</a>&nbsp;word)</pre>
<div class="block">Converts a <a href="../../danbikel/parser/Word.html" title="class in danbikel.parser"><code>Word</code></a> object into a preterminal subtree.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>word</code> - the word object from which to create a preterminal subtree</dd>
<dt><span class="strong">Returns:</span></dt><dd>a preterminal subtree constructed from <code>word</code></dd></dl>
</li>
</ul>
<a name="getCanonical(danbikel.lisp.Symbol)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getCanonical</h4>
<pre><a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;getCanonical(<a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label)</pre>
<div class="block">Returns a canonical version of the specified nonterminal label; if
 <code>label</code> already is in canonical form, it is returned.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>label</code> - the label to be canonicalized</dd></dl>
</li>
</ul>
<a name="getCanonical(danbikel.lisp.Symbol, boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getCanonical</h4>
<pre><a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;getCanonical(<a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label,
                  boolean&nbsp;stripAugmentations)</pre>
<div class="block">Returns a canonical version of the specified nonterminal label; if
 <code>label</code> already is in canonical form, it is returned.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>label</code> - the label to be canonicalized</dd><dd><code>stripAugmentations</code> - indicates whether to strip any augmentations
 from the specified label before attempting to get its canonical form</dd>
<dt><span class="strong">Returns:</span></dt><dd>the canonical version of the specified label</dd></dl>
</li>
</ul>
<a name="isSentence(danbikel.lisp.Symbol)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isSentence</h4>
<pre>boolean&nbsp;isSentence(<a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label)</pre>
<div class="block">Returns <code>true</code> is the specified nonterminal label represents a
 sentence in the current language's Treebank.  This method is intended to
 be used by implementations of <a href="../../danbikel/parser/Training.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)"><code>Training.relabelSubjectlessSentences(Sexp)</code></a>.</div>
</li>
</ul>
<a name="sentenceLabel()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sentenceLabel</h4>
<pre><a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;sentenceLabel()</pre>
<div class="block">Returns the canonical label for a sentence, for de-transforming sentences
 that were transformed via <a href="../../danbikel/parser/Training.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)"><code>Training.relabelSubjectlessSentences(Sexp)</code></a>.</div>
</li>
</ul>
<a name="subjectlessSentenceLabel()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subjectlessSentenceLabel</h4>
<pre><a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;subjectlessSentenceLabel()</pre>
<div class="block">Returns the symbol with which <a href="../../danbikel/parser/Training.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)"><code>Training.relabelSubjectlessSentences(Sexp)</code></a>
 will relabel sentences when they have no subjects.</div>
</li>
</ul>
<a name="subjectAugmentation()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subjectAugmentation</h4>
<pre><a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;subjectAugmentation()</pre>
<div class="block">Returns the symbol that is used to augment nonterminals to indicate matrix
 subjects in the current language's Treebank.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../danbikel/parser/Training.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)"><code>Training.relabelSubjectlessSentences(Sexp)</code></a></dd></dl>
</li>
</ul>
<a name="isNullElementPreterminal(danbikel.lisp.Sexp)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isNullElementPreterminal</h4>
<pre>boolean&nbsp;isNullElementPreterminal(<a href="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</pre>
<div class="block">Returns <code>true</code> if the specified S-expression represents
 a preterminal whose terminal element is the null element for the current
 language's Treebank.  This method is intended to be used by implementations
 of <a href="../../danbikel/parser/Training.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)"><code>Training.relabelSubjectlessSentences(Sexp)</code></a>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../danbikel/parser/Training.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)"><code>Training.relabelSubjectlessSentences(Sexp)</code></a></dd></dl>
</li>
</ul>
<a name="getTraceIndex(danbikel.lisp.Sexp, danbikel.parser.Nonterminal)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getTraceIndex</h4>
<pre>int&nbsp;getTraceIndex(<a href="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;preterm,
                <a href="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</a>&nbsp;nonterminal)</pre>
<div class="block">Returns the index of a trace for the specified null element preterminal.
 If <code>preterm</code> is not a null element preterminal (that is, a
 preterminal for which <a href="../../danbikel/parser/Treebank.html#isNullElementPreterminal(danbikel.lisp.Sexp)"><code>isNullElementPreterminal(Sexp)</code></a> returns
 <code>false</code>), the semantics of this method are undefined.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>preterm</code> - the null element preterminal whose trace index is to be
 returned</dd><dd><code>nonterminal</code> - the object used as the second argument to
 <a href="../../danbikel/parser/Treebank.html#parseNonterminal(danbikel.lisp.Symbol,%20danbikel.parser.Nonterminal)"><code>parseNonterminal(Symbol,Nonterminal)</code></a></dd>
<dt><span class="strong">Returns:</span></dt><dd>the index of the trace of the terminal contained in
 <code>preterm</code>, or -1 if the null element does not have an index</dd></dl>
</li>
</ul>
<a name="isPuncToRaise(danbikel.lisp.Sexp)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isPuncToRaise</h4>
<pre>boolean&nbsp;isPuncToRaise(<a href="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;preterm)</pre>
<div class="block">Returns <code>true</code> if the specified S-expression represents
 a preterminal and a part-of-speech tag that indicates punctuation
 to be raised when running <a href="../../danbikel/parser/Training.html#raisePunctuation(danbikel.lisp.Sexp)"><code>Training.raisePunctuation(Sexp)</code></a>.  If
 punctuation raising is not desirable for a particular language
 package, this method may be implemented simply to return
 <code>false</code>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>preterm</code> - the preterminal to test</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../danbikel/parser/Training.html#raisePunctuation(danbikel.lisp.Sexp)"><code>Training.raisePunctuation(Sexp)</code></a></dd></dl>
</li>
</ul>
<a name="isPunctuation(danbikel.lisp.Symbol)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isPunctuation</h4>
<pre>boolean&nbsp;isPunctuation(<a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;tag)</pre>
<div class="block">Returns <code>true</code> if the specified part of speech tag is one
 for which <a href="../../danbikel/parser/Treebank.html#isPuncToRaise(danbikel.lisp.Sexp)"><code>isPuncToRaise(Sexp)</code></a> would return <code>true</code>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>tag</code> - the part of speech to test</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../danbikel/parser/Treebank.html#isPuncToRaise(danbikel.lisp.Sexp)"><code>isPuncToRaise(Sexp)</code></a></dd></dl>
</li>
</ul>
<a name="isPossessivePreterminal(danbikel.lisp.Sexp)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isPossessivePreterminal</h4>
<pre>boolean&nbsp;isPossessivePreterminal(<a href="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</pre>
<div class="block">Returns <code>true</code> if the specified S-expression represents
 a preterminal that is the possessive part of speech.  This method is
 intended to be used by implementations of <a href="../../danbikel/parser/Training.html#addBaseNPs(danbikel.lisp.Sexp)"><code>Training.addBaseNPs(Sexp)</code></a>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../danbikel/parser/Training.html#addBaseNPs(danbikel.lisp.Sexp)"><code>Training.addBaseNPs(Sexp)</code></a></dd></dl>
</li>
</ul>
<a name="isNP(danbikel.lisp.Symbol)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isNP</h4>
<pre>boolean&nbsp;isNP(<a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label)</pre>
<div class="block">Returns <code>true</code> if the canonical version of the specified label
 is an NP for the current language's Treebank.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>label</code> - the label to test</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../danbikel/parser/Training.html#addBaseNPs(danbikel.lisp.Sexp)"><code>Training.addBaseNPs(Sexp)</code></a></dd></dl>
</li>
</ul>
<a name="baseNPLabel()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>baseNPLabel</h4>
<pre><a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;baseNPLabel()</pre>
<div class="block">Returns the symbol with which <a href="../../danbikel/parser/Training.html#addBaseNPs(danbikel.lisp.Sexp)"><code>Training.addBaseNPs(Sexp)</code></a> will
 relabel core NPs.<br>
 <b>N.B.</b>: This method should <i><b>not</b></i> be used as a predicate
 for testing whether a particular nonterminal label is that of a base NP.
 For that purpose, use <a href="../../danbikel/parser/Treebank.html#isBaseNP(danbikel.lisp.Symbol)"><code>isBaseNP(Symbol)</code></a>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../danbikel/parser/Training.html#addBaseNPs(danbikel.lisp.Sexp)"><code>Training.addBaseNPs(Sexp)</code></a></dd></dl>
</li>
</ul>
<a name="isBaseNP(danbikel.lisp.Symbol)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isBaseNP</h4>
<pre>boolean&nbsp;isBaseNP(<a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label)</pre>
<div class="block">Returns whether the specified label is for a base NP.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>label</code> - the label to test</dd>
<dt><span class="strong">Returns:</span></dt><dd>whether the specified label is for a base NP.</dd></dl>
</li>
</ul>
<a name="isWHNP(danbikel.lisp.Symbol)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isWHNP</h4>
<pre>boolean&nbsp;isWHNP(<a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label)</pre>
<div class="block">Returns <code>true</code> if the canonical version of the specified label
 is an NP that undergoes WH-movement in a particular Treebank.  This method
 is used by <a href="../../danbikel/parser/Training.html#addGapInformation(danbikel.lisp.Sexp)"><code>Training.addGapInformation(Sexp)</code></a>.  If a particular
 language package does not require gap information, then this method may be
 implemented simply to return <code>false</code>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../danbikel/parser/Training.html#addGapInformation(danbikel.lisp.Sexp)"><code>Training.addGapInformation(Sexp)</code></a></dd></dl>
</li>
</ul>
<a name="NPLabel()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>NPLabel</h4>
<pre><a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;NPLabel()</pre>
<div class="block">Returns the symbol that <a href="../../danbikel/parser/Training.html#addBaseNPs(danbikel.lisp.Sexp)"><code>Training.addBaseNPs(Sexp)</code></a> should
 add as a parent if a base NP is not dominated by an NP.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../danbikel/parser/Training.html#addBaseNPs(danbikel.lisp.Sexp)"><code>Training.addBaseNPs(Sexp)</code></a></dd></dl>
</li>
</ul>
<a name="isConjunction(danbikel.lisp.Symbol)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isConjunction</h4>
<pre>boolean&nbsp;isConjunction(<a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label)</pre>
<div class="block">Returns <code>true</code> if the canonical version of the specified label
 is a conjunction tag or nonterminal in a particular Treebank.</div>
</li>
</ul>
<a name="isVerb(danbikel.lisp.Sexp)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isVerb</h4>
<pre>boolean&nbsp;isVerb(<a href="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;preterminal)</pre>
<div class="block">Returns <code>true</code> if the specified preterminal is that of a verb.
 This method is used by <a href="../../danbikel/parser/HeadTreeNode.html" title="class in danbikel.parser"><code>HeadTreeNode</code></a> to determine if a particular
 subtree contains a verb, which is in turn used by <a href="../../danbikel/parser/Trainer.html" title="class in danbikel.parser"><code>Trainer</code></a> to
 calculate the distance metric, which depends on whether a verb occurs
 in the subtrees of the previous modifiers.  It is the responsibility
 of the caller to insure that <code>preterminal</code> is a
 <code>Sexp</code> object for which <a href="../../danbikel/parser/Treebank.html#isPreterminal(danbikel.lisp.Sexp)"><code>isPreterminal(Sexp)</code></a> returns
 <code>true</code>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../danbikel/parser/HeadTreeNode.html" title="class in danbikel.parser"><code>HeadTreeNode</code></a>, 
<a href="../../danbikel/parser/Trainer.html" title="class in danbikel.parser"><code>Trainer</code></a></dd></dl>
</li>
</ul>
<a name="isVerbTag(danbikel.lisp.Symbol)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isVerbTag</h4>
<pre>boolean&nbsp;isVerbTag(<a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;tag)</pre>
<div class="block">Returns <code>true</code> if the specified symbol is the part of speech
 tag of a verb.  This method should return true for exactly the same
 parts of speech for which <a href="../../danbikel/parser/Treebank.html#isVerb(danbikel.lisp.Sexp)"><code>isVerb(Sexp)</code></a> returns <code>true</code>,
 and is used to calculate the distance metric while decoding.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../danbikel/parser/CKYItem.html#containsVerb()"><code>CKYItem.containsVerb()</code></a>, 
<a href="../../danbikel/parser/Decoder.html" title="class in danbikel.parser"><code>Decoder</code></a></dd></dl>
</li>
</ul>
<a name="isComma(danbikel.lisp.Symbol)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isComma</h4>
<pre>boolean&nbsp;isComma(<a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;word)</pre>
<div class="block">Returns <code>true</code> if the specified word is a comma.  This method
 is used by the <code>Decoder</code> class when performing the comma
 constraint on chart items.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>word</code> - the word to test</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../danbikel/parser/Settings.html#decoderUseCommaConstraint"><code>Settings.decoderUseCommaConstraint</code></a></dd></dl>
</li>
</ul>
<a name="isLeftParen(danbikel.lisp.Symbol)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isLeftParen</h4>
<pre>boolean&nbsp;isLeftParen(<a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;word)</pre>
<div class="block">Returns <code>true</code> if the specified word is a left
 parenthesis.  This method is used by the <code>Decoder</code>
 class when performing the comma constraint on chart items.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>word</code> - the word to test</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../danbikel/parser/Settings.html#decoderUseCommaConstraint"><code>Settings.decoderUseCommaConstraint</code></a></dd></dl>
</li>
</ul>
<a name="isRightParen(danbikel.lisp.Symbol)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isRightParen</h4>
<pre>boolean&nbsp;isRightParen(<a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;word)</pre>
<div class="block">Returns <code>true</code> if the specified word is a right
 parenthesis.  This method is used by the <code>Decoder</code>
 class when performing the comma constraint on chart items.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>word</code> - the word to test</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../danbikel/parser/Settings.html#decoderUseCommaConstraint"><code>Settings.decoderUseCommaConstraint</code></a></dd></dl>
</li>
</ul>
<a name="augmentationDelimiters()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>augmentationDelimiters</h4>
<pre><a href="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;augmentationDelimiters()</pre>
<div class="block">Returns a string whose characters are the set of delimiters for complex
 nonterminal labels.
 <p/>
 <b>Implementation note</b>: The return value of this method should be used
 only to implement the other methods of interface.  Construction of and
 predicates over complex nonterminals should be handled by the other methods
 specified in this interface that either take a <a href="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser"><code>Nonterminal</code></a> as an
 argument or return a <a href="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser"><code>Nonterminal</code></a>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../danbikel/parser/Treebank.html#isAugDelim(danbikel.lisp.Sexp)"><code>isAugDelim(Sexp)</code></a>, 
<a href="../../danbikel/parser/Treebank.html#stripAugmentation(danbikel.lisp.Symbol)"><code>stripAugmentation(Symbol)</code></a>, 
<a href="../../danbikel/parser/Treebank.html#defaultParseNonterminal(danbikel.lisp.Symbol,%20danbikel.parser.Nonterminal)"><code>defaultParseNonterminal(Symbol,Nonterminal)</code></a></dd></dl>
</li>
</ul>
<a name="canonicalAugDelimiter()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>canonicalAugDelimiter</h4>
<pre>char&nbsp;canonicalAugDelimiter()</pre>
<div class="block">Returns the first character of the string returned by
 <a href="../../danbikel/parser/Treebank.html#augmentationDelimiters()"><code>augmentationDelimiters()</code></a>, which will be considered the
 &quot;canonical&quot; augmentation delimiter when adding
 new augmentations, such as the argument augmentations added by
 implementations of <a href="../../danbikel/parser/Training.html#identifyArguments(danbikel.lisp.Sexp)"><code>Training.identifyArguments(Sexp)</code></a>.</div>
</li>
</ul>
<a name="nonTreebankLeftBracket()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nonTreebankLeftBracket</h4>
<pre>char&nbsp;nonTreebankLeftBracket()</pre>
<div class="block">Returns a left-bracket character that is not an existing metacharacter
 in the current treebank, for use when the
 <a href="../../danbikel/parser/Settings.html#decoderOutputHeadLexicalizedLabels"><code>Settings.decoderOutputHeadLexicalizedLabels</code></a> is <tt>true</tt>.
 For most treebanks, <tt>'['</tt> is a good default.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>a left-bracket character that is not an existing metacharacter
 in the current treebank</dd></dl>
</li>
</ul>
<a name="nonTreebankRightBracket()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nonTreebankRightBracket</h4>
<pre>char&nbsp;nonTreebankRightBracket()</pre>
<div class="block">Returns a right-bracket character that is not an existing metacharacter in
 the current treebank, for use when constructing lexicalized nonterminals
 when the <a href="../../danbikel/parser/Settings.html#decoderOutputHeadLexicalizedLabels"><code>Settings.decoderOutputHeadLexicalizedLabels</code></a> is
 <tt>true</tt>. For most treebanks, <tt>']'</tt> is a good default.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>a right-bracket character that is not an existing metacharacter in
         the current treebank</dd></dl>
</li>
</ul>
<a name="nonTreebankDelimiter()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nonTreebankDelimiter</h4>
<pre>char&nbsp;nonTreebankDelimiter()</pre>
<div class="block">Returns a delimiter not already in use by the current treebank, for use
 when constructing lexicalized nonterminals when the <a href="../../danbikel/parser/Settings.html#decoderOutputHeadLexicalizedLabels"><code>Settings.decoderOutputHeadLexicalizedLabels</code></a> is <tt>true</tt>.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>a delimiter not already in use by the current treebank</dd></dl>
</li>
</ul>
<a name="stripAugmentation(danbikel.lisp.Symbol)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>stripAugmentation</h4>
<pre><a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;stripAugmentation(<a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label)</pre>
<div class="block">Returns the <code>Symbol</code> created by stripping off all
 augmentations, that is all characters after and including the first
 character that appears in the string returned by
 <a href="../../danbikel/parser/Treebank.html#augmentationDelimiters()"><code>augmentationDelimiters()</code></a>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>label</code> - the potentially-complex nonterminal label to be stripped</dd>
<dt><span class="strong">Returns:</span></dt><dd>a version of <code>label</code> with all augmentations removed</dd></dl>
</li>
</ul>
<a name="stripIndex(danbikel.lisp.Symbol)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>stripIndex</h4>
<pre><a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;stripIndex(<a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label)</pre>
<div class="block">Returns <code>label</code>, but stripped of any index augmentation.  This
 method assumes that the index will always be the final augmentation in a
 complex nonterminal label.<br><b>N.B.</b>: This method will create a new
 <code>Nonterminal</code> object, to be filled in by <a href="../../danbikel/parser/Treebank.html#stripIndex(danbikel.lisp.Symbol,%20danbikel.parser.Nonterminal)"><code>stripIndex(Symbol,Nonterminal)</code></a>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>label</code> - the nonterminal to be stripped of any possible index</dd>
<dt><span class="strong">Returns:</span></dt><dd>a <code>Symbol</code> that is identical to <code>label</code>,
 except that all characters after and including the final delimiter
 are removed if the final augmentation is composed entirely of digits</dd></dl>
</li>
</ul>
<a name="stripIndex(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>stripIndex</h4>
<pre><a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;stripIndex(<a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label,
                <a href="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</a>&nbsp;nonterminal)</pre>
<div class="block">Identical to <a href="../../danbikel/parser/Treebank.html#stripIndex(danbikel.lisp.Symbol)"><code>stripIndex(Symbol)</code></a>, except that instead of creating
 a new <code>Nonterminal</code> object for use by <a href="../../danbikel/parser/Treebank.html#parseNonterminal(danbikel.lisp.Symbol,%20danbikel.parser.Nonterminal)"><code>parseNonterminal(Symbol,Nonterminal)</code></a>, this method simply passes the
 specified <code>nonterminal</code> object.  In a sequential run, this
 method provides maximum efficiency, as only one <code>Nonterminal</code>
 object need be created at the beginning of the run.</div>
</li>
</ul>
<a name="stripAllButIndex(danbikel.lisp.Symbol)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>stripAllButIndex</h4>
<pre><a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;stripAllButIndex(<a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label)</pre>
<div class="block">Returns a symbol identical to the specified <code>label</code>, except
 all augmentations other than the index will be removed.  If
 <code>label</code> had no index to begin with, then this method
 is functionally identical to <a href="../../danbikel/parser/Treebank.html#stripAugmentation(danbikel.lisp.Symbol)"><code>stripAugmentation(Symbol)</code></a>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>label</code> - the nonterminal label to strip of non-index augmentations</dd></dl>
</li>
</ul>
<a name="stripAllButIndex(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>stripAllButIndex</h4>
<pre><a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;stripAllButIndex(<a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label,
                      <a href="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</a>&nbsp;nonterminal)</pre>
<div class="block">Identical to <a href="../../danbikel/parser/Treebank.html#stripAllButIndex(danbikel.lisp.Symbol)"><code>stripAllButIndex(Symbol)</code></a>, except that instead of
 creating a new <code>Nonterminal</code> object for use by
 <a href="../../danbikel/parser/Treebank.html#parseNonterminal(danbikel.lisp.Symbol,%20danbikel.parser.Nonterminal)"><code>parseNonterminal(Symbol,Nonterminal)</code></a>, this method
 uses the specified <code>nonterminal</code> object.  In a sequential
 run, this method provides maximum efficiency, as only one
 <code>Nonterminal</code> object need be created at the beginning
 of the run.</div>
</li>
</ul>
<a name="parseNonterminal(danbikel.lisp.Symbol)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>parseNonterminal</h4>
<pre><a href="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</a>&nbsp;parseNonterminal(<a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label)</pre>
<div class="block">Returns a <code>Nonterminal</code> object to represent all the
 components of a complex nonterminal annotation: the base label, any
 augmentations and any index.  If there are no augmentations, the
 <code>augmentations</code> field of the returned object will contain
 a list with zero elements; if there is no index, the
 value of index will be -1.  A final requirement of the contract of this
 method is to represent all the delimiters in the list of augmentations;
 this requirement is met, for example, by the helper method <a href="../../danbikel/parser/Treebank.html#defaultParseNonterminal(danbikel.lisp.Symbol,%20danbikel.parser.Nonterminal)"><code>defaultParseNonterminal(Symbol,Nonterminal)</code></a>.<br>
 <b>Efficiency note</b>: This method creates and returns a new
 <code>Nonterminal</code> object with every invocation.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>label</code> - a (possibly complex) nonterminal label from a Treebank</dd>
<dt><span class="strong">Returns:</span></dt><dd>a <code>Nonterminal</code> object representing any and
 all components of the specified complex nonterminal</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser"><code>Nonterminal</code></a></dd></dl>
</li>
</ul>
<a name="parseNonterminal(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>parseNonterminal</h4>
<pre><a href="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</a>&nbsp;parseNonterminal(<a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label,
                           <a href="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</a>&nbsp;nonterminal)</pre>
<div class="block">Identical to <a href="../../danbikel/parser/Treebank.html#parseNonterminal(danbikel.lisp.Symbol)"><code>parseNonterminal(Symbol)</code></a>, except that instead of
 returning a newly-created <code>Nonterminal</code> object, this
 method merely modifies the specified <code>Nonterminal</code> object.
 This method may be used for efficiency: in a particular, sequential
 training run, only one <code>Nonterminal</code> need be created,
 repeatedly passed in to this method for modification.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>label</code> - a (possibly complex) nonterminal label from a Treebank</dd><dd><code>nonterminal</code> - the representation of any and all components present
 in <code>label</code></dd></dl>
</li>
</ul>
<a name="defaultParseNonterminal(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>defaultParseNonterminal</h4>
<pre>void&nbsp;defaultParseNonterminal(<a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label,
                           <a href="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</a>&nbsp;nonterminal)</pre>
<div class="block">Fills in the specified <code>Nonterminal</code> object to represent
 all the components of a complex nonterminal annotation: the base label,
 any augmentations and any index.  If there are no augmentations, the
 <code>augmentations</code> field of the returned object will contain a
 list with no elements; if there is no index, the value of index will be
 -1.  Augmentation delimiters are the characters in the string returned by
 <a href="../../danbikel/parser/Treebank.html#augmentationDelimiters()"><code>augmentationDelimiters()</code></a>.<br><b>N.B.</b>: This method assumes that
 the index, if one exists for the specified nonterminal, will always be the
 final augmentation in the label.<br>This method is intended to be used by
 implementations of <a href="../../danbikel/parser/Treebank.html#parseNonterminal(danbikel.lisp.Symbol,%20danbikel.parser.Nonterminal)"><code>parseNonterminal(Symbol,Nonterminal)</code></a>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>label</code> - a (possibly complex) nonterminal label from a Treebank</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser"><code>Nonterminal</code></a></dd></dl>
</li>
</ul>
<a name="containsAugmentation(danbikel.lisp.Symbol, danbikel.lisp.Symbol)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>containsAugmentation</h4>
<pre>boolean&nbsp;containsAugmentation(<a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;nonterminal,
                           <a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;augmentation)</pre>
<div class="block">Provides an efficient, thread-safe method for testing whether the
 specified nonterminal contains the specified augmentation (without
 parsing the nonterminal).
 <p>
 <b>N.B.</b>: This method assumes that the augmentation is preceded
 by the canonical augmentation delimiter.  To search for an augmentation
 preceded by <i>any</i> of the possible augmentaion delimiters (as defined
 by <a href="../../danbikel/parser/Treebank.html#augmentationDelimiters()"><code>augmentationDelimiters()</code></a>), use
 <pre>
 parseNonterminal(nonterminal).augmentations.contains(augmentation)
 </pre></div>
</li>
</ul>
<a name="addAugmentation(danbikel.parser.Nonterminal, danbikel.lisp.Symbol)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addAugmentation</h4>
<pre>void&nbsp;addAugmentation(<a href="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</a>&nbsp;nonterminal,
                   <a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;augmentation)</pre>
<div class="block">Adds the specified augmentation to the end of the (possibly empty)
 augmentation list of the specified <code>Nonterminal</code> object.
 This method takes care to add the canonical augmentation delimiter
 before adding the augmentation itself, and also takes care to add
 these two elements before a final delimiter between the main augmentations
 and the index, if one exists.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>nonterminal</code> - the nonterminal to which to add an augmentation</dd><dd><code>augmentation</code> - the augmentation to add to <code>nonterminal</code>'s
 augmentation list</dd></dl>
</li>
</ul>
<a name="removeAugmentation(danbikel.parser.Nonterminal, danbikel.lisp.Symbol)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>removeAugmentation</h4>
<pre>boolean&nbsp;removeAugmentation(<a href="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</a>&nbsp;nonterminal,
                         <a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;augmentation)</pre>
<div class="block">Removes the specified augmentation from the augmentation list of the
 specified <code>Nonterminal</code> object, and the previous augmentation
 delimiter.  If the specified augmentation is <i>not</i> preceded by an
 augmentation delimiter, meaning it is the base label itself, then it is not
 removed.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>nonterminal</code> - the nonterminal from which to remove an augmentation</dd><dd><code>augmentation</code> - the augmentation to remove from <code>nonterminal</code></dd>
<dt><span class="strong">Returns:</span></dt><dd><code>true</code> if <code>augmentation</code> and a preceding
         augmentation delimiter was removed from <code>nonterminal</code>'s
         augmentation list, or <code>false</code> otherwise</dd></dl>
</li>
</ul>
<a name="removeAugmentation(danbikel.lisp.Sexp, danbikel.parser.Nonterminal, danbikel.lisp.Symbol)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>removeAugmentation</h4>
<pre><a href="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;removeAugmentation(<a href="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;sexp,
                      <a href="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</a>&nbsp;nonterminal,
                      <a href="../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;augmentation)</pre>
<div class="block">Removes the specified nonterminal augmentation from the specified
 S-expression, using the specified <a href="../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser"><code>Nonterminal</code></a> object for temporary
 storage.  If the specified S-expression is a list, then each element will
 be destructively replaced with the return value of this method; otherwise,
 if the specified S-epxression is a symbol, its augmentation is removed and
 the new symbol is returned.
 <p/>
 <b>N.B.</b>: While the description of the behavior of this method on lists
 is recursive, a concrete implementation need not use a recursive
 algorithm.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sexp</code> - the S-expression containing symbols whose augmentations
                     are to be removed</dd><dd><code>nonterminal</code> - an object used for temporary storage during the
                     invocation of this method</dd><dd><code>augmentation</code> - the augmentation to be removed from all symbols in the
                     specified S-expression</dd>
<dt><span class="strong">Returns:</span></dt><dd>the specified S-expression, but with all symbols changed so that
         none has the specified augmentation</dd></dl>
</li>
</ul>
<a name="isAugDelim(danbikel.lisp.Sexp)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>isAugDelim</h4>
<pre>boolean&nbsp;isAugDelim(<a href="../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;sexp)</pre>
<div class="block">Returns whether the specified S-expression is a symbol that is an
 augmentation delimiter for a complex nonterminal label.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sexp</code> - the S-expression to be tested</dd>
<dt><span class="strong">Returns:</span></dt><dd>whether the specified S-expression is a symbol that is an
 augmentation delimiter.</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../danbikel/parser/Treebank.html#augmentationDelimiters()"><code>augmentationDelimiters()</code></a></dd></dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Treebank.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
<div class="aboutLanguage"><em>Parsing Engine</em></div>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../danbikel/parser/Transition.html" title="class in danbikel.parser"><span class="strong">Prev Class</span></a></li>
<li><a href="../../danbikel/parser/Word.html" title="class in danbikel.parser"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?danbikel/parser/Treebank.html" target="_top">Frames</a></li>
<li><a href="Treebank.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small>Author: <a href="http://www.cis.upenn.edu/~dbikel/">Dan Bikel.</a></small></p>
</body>
</html>
