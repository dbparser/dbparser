<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (version 1.7.0-google-v6) on Thu Apr 16 08:46:54 PDT 2015 -->
<title>AbstractTraining (Dan Bikel's Parsing Engine)</title>
<meta name="date" content="2015-04-16">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="AbstractTraining (Dan Bikel\'s Parsing Engine)";
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/AbstractTraining.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
<div class="aboutLanguage"><em>Parsing Engine</em></div>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../danbikel/parser/lang/AbstractHeadFinder.HeadFindInstruction.html" title="class in danbikel.parser.lang"><span class="strong">Prev Class</span></a></li>
<li><a href="../../../danbikel/parser/lang/AbstractTreebank.html" title="class in danbikel.parser.lang"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?danbikel/parser/lang/AbstractTraining.html" target="_top">Frames</a></li>
<li><a href="AbstractTraining.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">danbikel.parser.lang</div>
<h2 title="Class AbstractTraining" class="title">Class AbstractTraining</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li><a href="http://java.sun.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">java.lang.Object</a></li>
<li>
<ul class="inheritance">
<li>danbikel.parser.lang.AbstractTraining</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Implemented Interfaces:</dt>
<dd><a href="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</a>, <a href="http://java.sun.com/javase/6/docs/api/java/io/Serializable.html?is-external=true" title="class or interface in java.io">Serializable</a></dd>
</dl>
<dl>
<dt>Direct Known Subclasses:</dt>
<dd><a href="../../../danbikel/parser/english/BrokenTraining.html" title="class in danbikel.parser.english">BrokenTraining</a>, <a href="../../../danbikel/parser/arabic/Training.html" title="class in danbikel.parser.arabic">Training</a>, <a href="../../../danbikel/parser/chinese/Training.html" title="class in danbikel.parser.chinese">Training</a>, <a href="../../../danbikel/parser/english/Training.html" title="class in danbikel.parser.english">Training</a></dd>
</dl>
<hr>
<br>
<pre>public abstract class <span class="strong">AbstractTraining</span>
extends <a href="http://java.sun.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>
implements <a href="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</a>, <a href="http://java.sun.com/javase/6/docs/api/java/io/Serializable.html?is-external=true" title="class or interface in java.io">Serializable</a></pre>
<div class="block">Provides methods for language-specific preprocessing of training
 parse trees.  The primary method to be invoked from this class is
 <a href="../../../danbikel/parser/lang/AbstractTraining.html#preProcess(danbikel.lisp.Sexp)"><code>preProcess(Sexp)</code></a>.  Additionally, as this class contains or
 has access to appropriate preprocessing data and methods, it also
 contains a crucial method to be used for post-processing, to
 &quot;undo&quot; what it has done during preprocessing after
 decoding.  This post-processing method is <a href="../../../danbikel/parser/lang/AbstractTraining.html#postProcess(danbikel.lisp.Sexp)"><code>postProcess(Sexp)</code></a>, and is invoked by default by the
 <code>Decoder</code>.
 <p>
 <b>Concurrency note</b>: As training is typically a sequential
 process, with very few noted exceptions, <i>none of the default
 implementations of the methods of this abstract base class is
 thread-safe</i>.  If thread-safe guarantees are desired, the
 methods of this class should be overridden.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../danbikel/parser/lang/AbstractTraining.html#preProcess(danbikel.lisp.Sexp)"><code>preProcess(Sexp)</code></a>, 
<a href="../../../danbikel/parser/lang/AbstractTraining.html#postProcess(danbikel.lisp.Sexp)"><code>postProcess(Sexp)</code></a>, 
<a href="../../../danbikel/parser/Decoder.html" title="class in danbikel.parser"><code>Decoder</code></a>, 
<a href="../../../serialized-form.html#danbikel.parser.lang.AbstractTraining">Serialized Form</a></dd></dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected static boolean</code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#addGapInfo">addGapInfo</a></strong></code>
<div class="block">Caches the boolean value of the property <a href="../../../danbikel/parser/Settings.html#addGapInfo"><code>Settings.addGapInfo</code></a>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected <a href="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#argAugmentations">argAugmentations</a></strong></code>
<div class="block">A list representing the set of all argument augmentations.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected <a href="http://java.sun.com/javase/6/docs/api/java/util/Map.html?is-external=true" title="class or interface in java.util">Map</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#argContexts">argContexts</a></strong></code>
<div class="block">Data member used to store the map required by the default implementation
 of the method <a href="../../../danbikel/parser/lang/AbstractTraining.html#identifyArguments(danbikel.lisp.Sexp)"><code>identifyArguments(Sexp)</code></a>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected static <a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#argContextsSym">argContextsSym</a></strong></code>
<div class="block">The symbol to indicate the list of argument-finding rules from a metadata
 resource.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected static <a href="http://java.sun.com/javase/6/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#argNonterminals">argNonterminals</a></strong></code>
<div class="block">Static set for storing argument nonterminals.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected <a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#baseNP">baseNP</a></strong></code>
<div class="block">The value of <a href="../../../danbikel/parser/Treebank.html#baseNPLabel()"><code>Treebank.baseNPLabel()</code></a>, cached for efficiency and
 convenience.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected <a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#canonicalAugDelimSym">canonicalAugDelimSym</a></strong></code>
<div class="block">A Symbol created from the first character of <a href="../../../danbikel/parser/Treebank.html#augmentationDelimiters()"><code>Treebank.augmentationDelimiters()</code></a>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected <a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#defaultArgAugmentation">defaultArgAugmentation</a></strong></code>
<div class="block">The symbol that will be used to identify argument nonterminals.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected <a href="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#delimAndGapStr">delimAndGapStr</a></strong></code>
<div class="block">The string consisting of the canonical augmentation delimiter
 concatenated with the gap augmentation, to be used in
 identifying nonterminals that contain gap augmentations.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#delimAndGapStrLen">delimAndGapStrLen</a></strong></code>
<div class="block">The length of <a href="../../../danbikel/parser/lang/AbstractTraining.html#delimAndGapStr"><code>delimAndGapStr</code></a>, cached here for efficiency
 and convenience.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected <a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#gapAugmentation">gapAugmentation</a></strong></code>
<div class="block">The symbol that will be used to identify nonterminals whose subtrees
 contain a gap (a trace).</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected <a href="../../../danbikel/parser/HeadFinder.html" title="interface in danbikel.parser">HeadFinder</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#headFinder">headFinder</a></strong></code>
<div class="block">Holds the value of <a href="../../../danbikel/parser/Language.html#headFinder()"><code>Language.headFinder()</code></a>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected static <a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#headPostSym">headPostSym</a></strong></code>
<div class="block">The symbol that is a possible mapping <a href="../../../danbikel/parser/lang/AbstractTraining.html#argContexts"><code>argContexts</code></a> to indicate
 to choose a child relative to the right side of the head as an argument.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected static <a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#headPreSym">headPreSym</a></strong></code>
<div class="block">The symbol that is a possible mapping <a href="../../../danbikel/parser/lang/AbstractTraining.html#argContexts"><code>argContexts</code></a> to indicate
 to choose a child relative to the left side of the head as an argument.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected static <a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#headSym">headSym</a></strong></code>
<div class="block">The symbol that is a possible mapping in <a href="../../../danbikel/parser/lang/AbstractTraining.html#argContexts"><code>argContexts</code></a> to indicate
 to choose a child relative to the head as an argument.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected static <a href="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#metadataPropertyPrefix">metadataPropertyPrefix</a></strong></code>
<div class="block">The prefix of the property of the metadata resource required by the
 default constructor of concrete subclasses.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected <a href="http://java.sun.com/javase/6/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#nodesToPrune">nodesToPrune</a></strong></code>
<div class="block">Data member to store the set of nodes to prune for the default
 implementation of <a href="../../../danbikel/parser/lang/AbstractTraining.html#prune(danbikel.lisp.Sexp)"><code>prune(Sexp)</code></a>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected static <a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#nodesToPruneSym">nodesToPruneSym</a></strong></code>
<div class="block">The symbol to indicate the list of nodes to prune.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected <a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#NP">NP</a></strong></code>
<div class="block">The value of <a href="../../../danbikel/parser/Treebank.html#NPLabel()"><code>Treebank.NPLabel()</code></a>, cached for efficiency and
 convenience.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected <a href="http://java.sun.com/javase/6/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#prunedPreterms">prunedPreterms</a></strong></code>
<div class="block">The set of preterminals (<code>Sexp</code> objects) that have been pruned
 away.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected <a href="http://java.sun.com/javase/6/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#prunedPunctuation">prunedPunctuation</a></strong></code>
<div class="block">The set of preterminals (<code>Sexp</code> objects) that were "raised
 away" by <a href="../../../danbikel/parser/lang/AbstractTraining.html#raisePunctuation(danbikel.lisp.Sexp)"><code>raisePunctuation(Sexp)</code></a> because they appeared either at
 the beginning or the end of a sentence.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected static boolean</code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#relabelHeadChildrenAsArgs">relabelHeadChildrenAsArgs</a></strong></code>
<div class="block">Indicates to relabel head children as arguments.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected static boolean</code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#repairBaseNPs">repairBaseNPs</a></strong></code>
<div class="block">Caches the boolean value of the property
 <a href="../../../danbikel/parser/Settings.html#collinsRepairBaseNPs"><code>Settings.collinsRepairBaseNPs</code></a>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected static <a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#semTagArgStopListSym">semTagArgStopListSym</a></strong></code>
<div class="block">The symbol to indicate the list of node augmentations that prevent
 a node from being relabeled</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected <a href="http://java.sun.com/javase/6/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#semTagArgStopSet">semTagArgStopSet</a></strong></code>
<div class="block">Data member used to store the set required by the method <a href="../../../danbikel/parser/lang/AbstractTraining.html#identifyArguments(danbikel.lisp.Sexp)"><code>identifyArguments(Sexp)</code></a>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected <a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#traceTag">traceTag</a></strong></code>
<div class="block">The symbol that gets assigned as the part of speech for null
 preterminals that represent traces that have undergone WH-movement, as
 relabeled by the default implementation of <a href="../../../danbikel/parser/lang/AbstractTraining.html#addGapInformation(danbikel.lisp.Sexp)"><code>addGapInformation(Sexp)</code></a>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected <a href="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#treebank">treebank</a></strong></code>
<div class="block">Holds the value of <a href="../../../danbikel/parser/Language.html#treebank()"><code>Language.treebank()</code></a>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected <a href="http://java.sun.com/javase/6/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#wordsToPrune">wordsToPrune</a></strong></code>
<div class="block">Data member to store the set of words to prune for the default
 implementation of <a href="../../../danbikel/parser/lang/AbstractTraining.html#prune(danbikel.lisp.Sexp)"><code>prune(Sexp)</code></a>.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier</th>
<th class="colLast" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected </code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#AbstractTraining()">AbstractTraining</a></strong>()</code>
<div class="block">Default constructor for this abstract base class; sets <a href="../../../danbikel/parser/lang/AbstractTraining.html#argContexts"><code>argContexts</code></a> to a new <code>Map</code> object, sets <a href="../../../danbikel/parser/lang/AbstractTraining.html#semTagArgStopSet"><code>semTagArgStopSet</code></a> to a new <code>Set</code> object and initializes <a href="../../../danbikel/parser/lang/AbstractTraining.html#canonicalAugDelimSym"><code>canonicalAugDelimSym</code></a>.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected boolean</code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#addArgAugmentation(danbikel.lisp.Symbol,%20danbikel.parser.Nonterminal)">addArgAugmentation</a></strong>(<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label,
                  <a href="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</a>&nbsp;nonterminal)</code>
<div class="block">Adds the default argument augmentation to the specified nonterminal
 if the specified label is not already an argument.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#addBaseNPs(danbikel.lisp.Sexp)">addBaseNPs</a></strong>(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</code>
<div class="block">Adds and/or relabels base NPs, which are defined in this default
 implementation to be NPs that do not dominate other non-possessive NPs,
 where a possessive NP is defined to be an NP that itself dominates
 a possessive preterminal, as determined by the implementation of the
 method <a href="../../../danbikel/parser/Treebank.html#isPossessivePreterminal(danbikel.lisp.Sexp)"><code>Treebank.isPossessivePreterminal(Sexp)</code></a>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#addGapInformation(danbikel.lisp.Sexp)">addGapInformation</a></strong>(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</code>
<div class="block">Augments nonterminals to include gap information for WHNP's that have
 moved and leave traces (gaps), as in the GPSG framework.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="http://java.sun.com/javase/6/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#argNonterminals()">argNonterminals</a></strong>()</code>
<div class="block">Returns a static set of possible argument nonterminals.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#canonicalizeNonterminals(danbikel.lisp.Sexp)">canonicalizeNonterminals</a></strong>(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</code>
<div class="block">Modifies each nonterminal in the specified tree to be its canonical
 version.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#collectPreterms(java.util.Set,%20danbikel.lisp.Sexp)">collectPreterms</a></strong>(<a href="http://java.sun.com/javase/6/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</a>&nbsp;preterms,
               <a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</code>
<div class="block">Adds all preterminal subtrees to the specified set.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#createArgAugmentationsList()">createArgAugmentationsList</a></strong>()</code>
<div class="block">A helper method that runs through every nonterminal "pattern" for each
 context in <a href="../../../danbikel/parser/lang/AbstractTraining.html#argContexts"><code>argContexts</code></a>, parses the pattern using <a href="../../../danbikel/parser/Treebank.html#parseNonterminal(danbikel.lisp.Symbol)"><code>Treebank.parseNonterminal(danbikel.lisp.Symbol)</code></a>, runs through the resulting list of
 augmentations and adds each augmentation symbol to the <a href="../../../danbikel/parser/lang/AbstractTraining.html#argAugmentations"><code>argAugmentations</code></a> list.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#createArgNonterminalsSet()">createArgNonterminalsSet</a></strong>()</code>
<div class="block">Sets the <a href="../../../danbikel/parser/lang/AbstractTraining.html#argNonterminals"><code>argNonterminals</code></a> data member to be the static set
 of argument nonterminals.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#defaultArgAugmentation()">defaultArgAugmentation</a></strong>()</code>
<div class="block">The symbol that is used to mark argument (required) nonterminals by
 <a href="../../../danbikel/parser/lang/AbstractTraining.html#identifyArguments(danbikel.lisp.Sexp)"><code>identifyArguments(Sexp)</code></a>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#gapAugmentation()">gapAugmentation</a></strong>()</code>
<div class="block">The symbol that will be used to identify nonterminals whose subtrees
 contain a gap (a trace).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#getCanonicalArg(danbikel.lisp.Symbol)">getCanonicalArg</a></strong>(<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label)</code>
<div class="block">Returns the canonical version of the specified argument nonterminal.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#getCanonicalArg(danbikel.lisp.Symbol,%20danbikel.parser.Nonterminal)">getCanonicalArg</a></strong>(<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label,
               <a href="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</a>&nbsp;nonterminal)</code>
<div class="block">Returns the canonical version of the specified argument nonterminal.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="http://java.sun.com/javase/6/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#getPrunedPreterms()">getPrunedPreterms</a></strong>()</code>
<div class="block">Returns the set of pruned preterminals (<code>Sexp</code> objects).</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="http://java.sun.com/javase/6/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#getPrunedPunctuation()">getPrunedPunctuation</a></strong>()</code>
<div class="block">Returns the set of preterminals (<code>Sexp</code> objects) that were
 punctuation elements that were "raised away" because they were either at
 the beginning or end of a sentence.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#hasGap(danbikel.lisp.Sexp,%20danbikel.lisp.Sexp,%20java.util.ArrayList)">hasGap</a></strong>(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree,
      <a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;root,
      <a href="http://java.sun.com/javase/6/docs/api/java/util/ArrayList.html?is-external=true" title="class or interface in java.util">ArrayList</a>&nbsp;indexStack)</code>
<div class="block">Returns -1 if <code>tree</code> has no gap (trace), or the index of the
 trace otherwise.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#hasGap(danbikel.lisp.Symbol)">hasGap</a></strong>(<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label)</code>
<div class="block">Returns <code>true</code> if and only if <code>label</code> has a
 gap augmentation as added by <a href="../../../danbikel/parser/lang/AbstractTraining.html#addGapInformation(danbikel.lisp.Sexp)"><code>addGapInformation(Sexp)</code></a>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected boolean</code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#hasPossessiveChild(danbikel.lisp.Sexp)">hasPossessiveChild</a></strong>(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</code>
<div class="block">Returns <code>true</code> if <code>tree</code> contains a child for which
 <a href="../../../danbikel/parser/Treebank.html#isPossessivePreterminal(danbikel.lisp.Sexp)"><code>Treebank.isPossessivePreterminal(Sexp)</code></a> returns
 <code>true</code>, <code>false</code> otherwise.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#headPostSym()">headPostSym</a></strong>()</code>
<div class="block">The symbol that is a possible mapping <a href="../../../danbikel/parser/lang/AbstractTraining.html#argContexts"><code>argContexts</code></a> to indicate to
 choose a child relative to the right side of the head as an argument.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#headPreSym()">headPreSym</a></strong>()</code>
<div class="block">The symbol that is a possible mapping <a href="../../../danbikel/parser/lang/AbstractTraining.html#argContexts"><code>argContexts</code></a> to indicate
 to choose a child relative to the left side of the head as an argument.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#headSym()">headSym</a></strong>()</code>
<div class="block">Returns the symbol used in the <a href="../../../danbikel/parser/lang/AbstractTraining.html#argContexts"><code>argContexts</code></a> map to identify
 an offset from the head child.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#identifyArguments(danbikel.lisp.Sexp)">identifyArguments</a></strong>(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</code>
<div class="block">Augments labels of nonterminals that are arguments.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#isAllNodesToPrune(danbikel.lisp.Sexp)">isAllNodesToPrune</a></strong>(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</code>
<div class="block">Returns whether all words or preterminals of this tree are to be pruned.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#isArgument(danbikel.lisp.Symbol)">isArgument</a></strong>(<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label)</code>
<div class="block">Returns <code>true</code> if and only if <code>label</code> has an
 argument augmentation as added by <a href="../../../danbikel/parser/lang/AbstractTraining.html#identifyArguments(danbikel.lisp.Sexp)"><code>identifyArguments(Sexp)</code></a>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected boolean</code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#isArgument(danbikel.lisp.Symbol,%20danbikel.parser.Nonterminal)">isArgument</a></strong>(<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label,
          <a href="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</a>&nbsp;nonterminal)</code>
<div class="block">Returns <code>true</code> if the specified nonterminal label has an
 argument augmentation.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected boolean</code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#isArgument(danbikel.lisp.Symbol,%20danbikel.parser.Nonterminal,%20boolean)">isArgument</a></strong>(<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label,
          <a href="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</a>&nbsp;nonterminal,
          boolean&nbsp;parseLabel)</code>
<div class="block">Returns <code>true</code> if the specified nonterminal label has an
 argument augmentation.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#isArgumentFast(danbikel.lisp.Symbol)">isArgumentFast</a></strong>(<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label)</code>
<div class="block">Returns <code>true</code> if the specified nonterminal label has an
 argument augmentation.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected boolean</code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#isCoordinatedPhrase(danbikel.lisp.Sexp,%20int)">isCoordinatedPhrase</a></strong>(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree,
                   int&nbsp;headIdx)</code>
<div class="block">Returns <code>true</code> if a non-head child of the specified
 tree is a conjunction, and that conjunction is either post-head
 but non-final, or immediately pre-head but non-initial (where
 &quot;immediately pre-head&quot; means &quot;at the first index
 less than <code>headIdx</code> that is not punctuation, as determined
 by <a href="../../../danbikel/parser/Treebank.html#isPunctuation(danbikel.lisp.Symbol)"><code>Treebank.isPunctuation(Symbol)</code></a>).</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected boolean</code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#isTypeOfSentence(danbikel.lisp.Symbol)">isTypeOfSentence</a></strong>(<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label)</code>
<div class="block">A helper method used by <a href="../../../danbikel/parser/lang/AbstractTraining.html#repairBaseNPs(danbikel.lisp.Sexp,%20int,%20danbikel.lisp.Sexp)"><code>repairBaseNPs(Sexp,int,Sexp)</code></a>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#isValidTree(danbikel.lisp.Sexp)">isValidTree</a></strong>(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</code>
<div class="block">Returns <code>true</code> if <code>tree</code> is a preterminal (the base
 case) or is a list with the first element of type <code>Symbol</code> (the
 node label) and subsequent elements are valid trees (the recursive case).</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#main(java.lang.String[])">main</a></strong>(<a href="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>[]&nbsp;args)</code>
<div class="block">Test driver for this class.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected boolean</code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#needToAddNormalNPLevel(danbikel.lisp.Sexp,%20int,%20danbikel.lisp.Sexp)">needToAddNormalNPLevel</a></strong>(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;grandparent,
                      int&nbsp;parentIdx,
                      <a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</code>
<div class="block">Returns <code>true</code> if a unary NP needs to be added above the
 specified base NP.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#postProcess(danbikel.lisp.Sexp)">postProcess</a></strong>(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</code>
<div class="block">Post-processes a parse tree after decoding, eseentially undoing
 the steps performed in <a href="../../../danbikel/parser/Training.html#preProcess(danbikel.lisp.Sexp)">preprocessing</a>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#preProcess(danbikel.lisp.Sexp)">preProcess</a></strong>(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</code>
<div class="block">The method to call before counting events in a training parse tree.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#preProcessTest(danbikel.lisp.SexpList,%20danbikel.lisp.SexpList,%20danbikel.lisp.SexpList)">preProcessTest</a></strong>(<a href="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</a>&nbsp;sentence,
              <a href="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</a>&nbsp;originalWords,
              <a href="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</a>&nbsp;tags)</code>
<div class="block">Preprocesses the specified test sentence and its coordinated list of tags.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#printMetadata()">printMetadata</a></strong>()</code>
<div class="block">Debugging method to print the metadata used by this class.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#prune(danbikel.lisp.Sexp)">prune</a></strong>(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</code>
<div class="block">Prunes away subtrees that have a root that is an element of
 <code>nodesToPrune</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#raisePunctuation(danbikel.lisp.Sexp)">raisePunctuation</a></strong>(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</code>
<div class="block">Raises punctuation to the highest possible point in a parse tree,
 resulting in a tree where no punctuation is the first or last child of a
 non-leaf node.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#readMetadata(danbikel.lisp.SexpTokenizer)">readMetadata</a></strong>(<a href="../../../danbikel/lisp/SexpTokenizer.html" title="class in danbikel.lisp">SexpTokenizer</a>&nbsp;metadataTok)</code>
<div class="block">Reads metadata to fill in <a href="../../../danbikel/parser/lang/AbstractTraining.html#argContexts"><code>argContexts</code></a> and
 <a href="../../../danbikel/parser/lang/AbstractTraining.html#semTagArgStopSet"><code>semTagArgStopSet</code></a>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#readMetadataHook(danbikel.lisp.Symbol,%20int,%20danbikel.lisp.SexpList)">readMetadataHook</a></strong>(<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;dataType,
                int&nbsp;metadataLen,
                <a href="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</a>&nbsp;metadata)</code>
<div class="block">A hook for subclasses to have their own custom metadata types.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#relabelArgChildren(danbikel.lisp.SexpList,%20int,%20danbikel.lisp.SexpList)">relabelArgChildren</a></strong>(<a href="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</a>&nbsp;treeList,
                  int&nbsp;headIdx,
                  <a href="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</a>&nbsp;candidatePatterns)</code>
<div class="block">Relabels as arguments all immediately-dominated children in the specified
 subtree accoding to the specified argument-finding patterns.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)">relabelSubjectlessSentences</a></strong>(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</code>
<div class="block">Relabels sentences that have no subjects with the nonterminal label
 returned by <a href="../../../danbikel/parser/Treebank.html#subjectlessSentenceLabel()"><code>Treebank.subjectlessSentenceLabel()</code></a>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#removeArgAugmentation(danbikel.lisp.Symbol)">removeArgAugmentation</a></strong>(<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label)</code>
<div class="block">Removes any argument augmentations from the specified nonterminal label.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected <a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#removeArgAugmentation(danbikel.lisp.Symbol,%20danbikel.parser.Nonterminal)">removeArgAugmentation</a></strong>(<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label,
                     <a href="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</a>&nbsp;nonterminal)</code>
<div class="block">Parses label into the specified <a href="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser"><code>Nonterminal</code></a> object and then
 removes all argument augmentations.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#removeGapAugmentation(danbikel.lisp.Sexp)">removeGapAugmentation</a></strong>(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;sexp)</code>
<div class="block">If the specified S-expression is a list, this method modifies the
 list to contain only symbols without gap augmentations;
 otherwise, this method removes the gap augmentation (if one exists)
 in the specified symbol and returns that new symbol.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#removeNullElements(danbikel.lisp.Sexp)">removeNullElements</a></strong>(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</code>
<div class="block">Removes all null elements, that is, those nodes of <code>tree</code> for
 which <a href="../../../danbikel/parser/Treebank.html#isNullElementPreterminal(danbikel.lisp.Sexp)"><code>Treebank.isNullElementPreterminal(Sexp)</code></a> returns
 <code>true</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#removeOnlyChildBaseNPs(danbikel.lisp.Sexp)">removeOnlyChildBaseNPs</a></strong>(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</code>
<div class="block">Handle case where an NP dominates a base NP and has no other children
 (the base NP is an "only child" of the dominating NP).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#removeWord(danbikel.lisp.Symbol,%20danbikel.lisp.Symbol,%20int,%20danbikel.lisp.SexpList,%20danbikel.lisp.SexpList,%20danbikel.lisp.SexpList,%20java.util.Set,%20java.util.Map)">removeWord</a></strong>(<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;word,
          <a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;tag,
          int&nbsp;idx,
          <a href="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</a>&nbsp;sentence,
          <a href="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</a>&nbsp;tags,
          <a href="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</a>&nbsp;originalTags,
          <a href="http://java.sun.com/javase/6/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</a>&nbsp;prunedPretermsPosSet,
          <a href="http://java.sun.com/javase/6/docs/api/java/util/Map.html?is-external=true" title="class or interface in java.util">Map</a>&nbsp;prunedPretermsPosMap)</code>
<div class="block">Invoked by the <a href="../../../danbikel/parser/Decoder.html" title="class in danbikel.parser">decoder</a> as the first
 step in preprocessing (prior to the invocation of <a href="../../../danbikel/parser/Training.html#preProcessTest(danbikel.lisp.SexpList,%20danbikel.lisp.SexpList,%20danbikel.lisp.SexpList)"><code>Training.preProcessTest(danbikel.lisp.SexpList, danbikel.lisp.SexpList, danbikel.lisp.SexpList)</code></a>).</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#repairBaseNPs(danbikel.lisp.Sexp)">repairBaseNPs</a></strong>(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</code>
<div class="block">Changes the specified tree so that when the last child of an
 NPB is an S, the S gets raised to be a sibling immediately following
 the NPB.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected <a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#repairBaseNPs(danbikel.lisp.Sexp,%20int,%20danbikel.lisp.Sexp)">repairBaseNPs</a></strong>(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;grandparent,
             int&nbsp;parentIdx,
             <a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</code>
<div class="block">Changes the specified tree so that when the last child of an
 NPB is an S, the S gets raised to be a sibling immediately following
 the NPB.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#setUpFastArgMap(danbikel.parser.CountsTable)">setUpFastArgMap</a></strong>(<a href="../../../danbikel/parser/CountsTable.html" title="interface in danbikel.parser">CountsTable</a>&nbsp;nonterminals)</code>
<div class="block">Indicates to set up a static map for quickly mapping argument nonterminals
 to their non-argument variants (that is, for quickly stripping away
 their argument augmentations).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#skip(danbikel.lisp.Sexp)">skip</a></strong>(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</code>
<div class="block">Returns whether the specified tree is to be skipped when training.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#startSym()">startSym</a></strong>()</code>
<div class="block">Returns the symbol to indicate hidden nonterminals that precede the first
 in a sequence of modifier nonterminals.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../danbikel/parser/Word.html" title="class in danbikel.parser">Word</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#startWord()">startWord</a></strong>()</code>
<div class="block">Returns the <code>Word</code> object that represents the hidden "head
 word" of the start symbol.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected static void</code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#staticSetUpFastArgMap(danbikel.parser.CountsTable)">staticSetUpFastArgMap</a></strong>(<a href="../../../danbikel/parser/CountsTable.html" title="interface in danbikel.parser">CountsTable</a>&nbsp;nonterminals)</code>
<div class="block">Indicates to set up a static map for quickly mapping argument nonterminals
 to their non-argument variants (that is, for quickly stripping away
 their argument augmentations).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#stopSym()">stopSym</a></strong>()</code>
<div class="block">Returns the symbol to indicate a hidden nonterminal that follows the last
 in a sequence of modifier nonterminals.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../danbikel/parser/Word.html" title="class in danbikel.parser">Word</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#stopWord()">stopWord</a></strong>()</code>
<div class="block">Returns the <code>Word</code> object that represents the hidden "head
 word" of the stop symbol.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#stripAugmentations(danbikel.lisp.Sexp)">stripAugmentations</a></strong>(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</code>
<div class="block">Strips any augmentations off all of the nonterminal labels of
 <code>tree</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected <a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#stripAugmentations(danbikel.lisp.Symbol)">stripAugmentations</a></strong>(<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label)</code>
<div class="block">Parses the specified nonterminal label and removes all augmentations.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#stripAugmentations(danbikel.lisp.Symbol,%20danbikel.parser.Nonterminal,%20boolean)">stripAugmentations</a></strong>(<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label,
                  <a href="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</a>&nbsp;nonterminal,
                  boolean&nbsp;parseLabel)</code>
<div class="block">Fills in the specified <a href="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser"><code>Nonterminal</code></a> object with the specified
 nonterminal label but without any augmentations.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected <a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#threadNPArgAugmentations(danbikel.lisp.Sexp)">threadNPArgAugmentations</a></strong>(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</code>
<div class="block">Adds any argument augmentations on an NP to its head child, continuing
 recursively until reaching a preterminal.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#topSym()">topSym</a></strong>()</code>
<div class="block">Returns the symbol to indicate the hidden root of all parse trees.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../danbikel/parser/Word.html" title="class in danbikel.parser">Word</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#topWord()">topWord</a></strong>()</code>
<div class="block">Returns the <code>Word</code> object that represents the hidden "head
 word" of the hidden root of all parse trees.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#traceTag()">traceTag</a></strong>()</code>
<div class="block">The symbol that gets reassigned as the part of speech for null
 preterminals that represent traces that have undergone WH-movement, as
 relabeled by the default implementation of <a href="../../../danbikel/parser/lang/AbstractTraining.html#addGapInformation(danbikel.lisp.Sexp)"><code>addGapInformation(Sexp)</code></a>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a></code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#transformSubjectNTs(danbikel.lisp.Sexp)">transformSubjectNTs</a></strong>(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</code>
<div class="block">Transforms nonterminals marked with a subject augmentation so that their
 unaugmented base label is the concatenation of the original base label
 plus the subject augmentation.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected boolean</code></td>
<td class="colLast"><code><strong><a href="../../../danbikel/parser/lang/AbstractTraining.html#unaryProductionsToNull(danbikel.lisp.Sexp)">unaryProductionsToNull</a></strong>(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</code>
<div class="block">Returns whether the specified subtree consists solely of unary productions
 going to a null element terminal.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.<a href="http://java.sun.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a></h3>
<code><a href="http://java.sun.com/javase/6/docs/api/java/lang/Object.html?is-external=true#clone()" title="class or interface in java.lang">clone</a>, <a href="http://java.sun.com/javase/6/docs/api/java/lang/Object.html?is-external=true#equals(java.lang.Object)" title="class or interface in java.lang">equals</a>, <a href="http://java.sun.com/javase/6/docs/api/java/lang/Object.html?is-external=true#finalize()" title="class or interface in java.lang">finalize</a>, <a href="http://java.sun.com/javase/6/docs/api/java/lang/Object.html?is-external=true#getClass()" title="class or interface in java.lang">getClass</a>, <a href="http://java.sun.com/javase/6/docs/api/java/lang/Object.html?is-external=true#hashCode()" title="class or interface in java.lang">hashCode</a>, <a href="http://java.sun.com/javase/6/docs/api/java/lang/Object.html?is-external=true#notify()" title="class or interface in java.lang">notify</a>, <a href="http://java.sun.com/javase/6/docs/api/java/lang/Object.html?is-external=true#notifyAll()" title="class or interface in java.lang">notifyAll</a>, <a href="http://java.sun.com/javase/6/docs/api/java/lang/Object.html?is-external=true#toString()" title="class or interface in java.lang">toString</a>, <a href="http://java.sun.com/javase/6/docs/api/java/lang/Object.html?is-external=true#wait()" title="class or interface in java.lang">wait</a>, <a href="http://java.sun.com/javase/6/docs/api/java/lang/Object.html?is-external=true#wait(long)" title="class or interface in java.lang">wait</a>, <a href="http://java.sun.com/javase/6/docs/api/java/lang/Object.html?is-external=true#wait(long,%20int)" title="class or interface in java.lang">wait</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a name="relabelHeadChildrenAsArgs">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>relabelHeadChildrenAsArgs</h4>
<pre>protected static&nbsp;boolean relabelHeadChildrenAsArgs</pre>
<div class="block">Indicates to relabel head children as arguments.  Such relabeling is
 unnecessary, since head children are already inherently distinct.  This
 flag should be true when emulating the behavior of Mike Collins' parser.</div>
</li>
</ul>
<a name="addGapInfo">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addGapInfo</h4>
<pre>protected static&nbsp;boolean addGapInfo</pre>
<div class="block">Caches the boolean value of the property <a href="../../../danbikel/parser/Settings.html#addGapInfo"><code>Settings.addGapInfo</code></a>.</div>
</li>
</ul>
<a name="repairBaseNPs">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>repairBaseNPs</h4>
<pre>protected static&nbsp;boolean repairBaseNPs</pre>
<div class="block">Caches the boolean value of the property
 <a href="../../../danbikel/parser/Settings.html#collinsRepairBaseNPs"><code>Settings.collinsRepairBaseNPs</code></a>.</div>
</li>
</ul>
<a name="argNonterminals">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>argNonterminals</h4>
<pre>protected static&nbsp;<a href="http://java.sun.com/javase/6/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</a> argNonterminals</pre>
<div class="block">Static set for storing argument nonterminals.</div>
</li>
</ul>
<a name="argContextsSym">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>argContextsSym</h4>
<pre>protected static final&nbsp;<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a> argContextsSym</pre>
<div class="block">The symbol to indicate the list of argument-finding rules from a metadata
 resource.</div>
</li>
</ul>
<a name="semTagArgStopListSym">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>semTagArgStopListSym</h4>
<pre>protected static final&nbsp;<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a> semTagArgStopListSym</pre>
<div class="block">The symbol to indicate the list of node augmentations that prevent
 a node from being relabeled</div>
</li>
</ul>
<a name="nodesToPruneSym">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nodesToPruneSym</h4>
<pre>protected static final&nbsp;<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a> nodesToPruneSym</pre>
<div class="block">The symbol to indicate the list of nodes to prune.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../danbikel/parser/lang/AbstractTraining.html#nodesToPrune"><code>nodesToPrune</code></a>, 
<a href="../../../danbikel/parser/lang/AbstractTraining.html#prune(danbikel.lisp.Sexp)"><code>prune(Sexp)</code></a></dd></dl>
</li>
</ul>
<a name="metadataPropertyPrefix">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>metadataPropertyPrefix</h4>
<pre>protected static final&nbsp;<a href="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a> metadataPropertyPrefix</pre>
<div class="block">The prefix of the property of the metadata resource required by the
 default constructor of concrete subclasses.  The value of this constant
 is <code>&quot;parser.training.metadata.&quot;</code>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#danbikel.parser.lang.AbstractTraining.metadataPropertyPrefix">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="treebank">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>treebank</h4>
<pre>protected&nbsp;<a href="../../../danbikel/parser/Treebank.html" title="interface in danbikel.parser">Treebank</a> treebank</pre>
<div class="block">Holds the value of <a href="../../../danbikel/parser/Language.html#treebank()"><code>Language.treebank()</code></a>.</div>
</li>
</ul>
<a name="headFinder">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>headFinder</h4>
<pre>protected&nbsp;<a href="../../../danbikel/parser/HeadFinder.html" title="interface in danbikel.parser">HeadFinder</a> headFinder</pre>
<div class="block">Holds the value of <a href="../../../danbikel/parser/Language.html#headFinder()"><code>Language.headFinder()</code></a>.</div>
</li>
</ul>
<a name="gapAugmentation">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>gapAugmentation</h4>
<pre>protected&nbsp;<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a> gapAugmentation</pre>
<div class="block">The symbol that will be used to identify nonterminals whose subtrees
 contain a gap (a trace).  This method is used by <a href="../../../danbikel/parser/lang/AbstractTraining.html#stripAugmentations(danbikel.lisp.Sexp)"><code>stripAugmentations(Sexp)</code></a>, so that gap augmentations that are added by
 <a href="../../../danbikel/parser/lang/AbstractTraining.html#addGapInformation(danbikel.lisp.Sexp)"><code>addGapInformation(Sexp)</code></a> do not get removed.  The default value is
 the symbol returned by <code>Symbol.add(&quot;g&quot;)</code>.  If this
 default value conflicts with an augmentation already used in a particular
 Treebank, this value should be reassigned in the constructor of a
 subclass.</div>
</li>
</ul>
<a name="delimAndGapStr">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>delimAndGapStr</h4>
<pre>protected&nbsp;<a href="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a> delimAndGapStr</pre>
<div class="block">The string consisting of the canonical augmentation delimiter
 concatenated with the gap augmentation, to be used in
 identifying nonterminals that contain gap augmentations.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../danbikel/parser/Treebank.html#canonicalAugDelimiter()"><code>Treebank.canonicalAugDelimiter()</code></a>, 
<a href="../../../danbikel/parser/lang/AbstractTraining.html#gapAugmentation"><code>gapAugmentation</code></a></dd></dl>
</li>
</ul>
<a name="delimAndGapStrLen">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>delimAndGapStrLen</h4>
<pre>protected&nbsp;int delimAndGapStrLen</pre>
<div class="block">The length of <a href="../../../danbikel/parser/lang/AbstractTraining.html#delimAndGapStr"><code>delimAndGapStr</code></a>, cached here for efficiency
 and convenience.</div>
</li>
</ul>
<a name="defaultArgAugmentation">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>defaultArgAugmentation</h4>
<pre>protected&nbsp;<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a> defaultArgAugmentation</pre>
<div class="block">The symbol that will be used to identify argument nonterminals.  This
 method is used by <a href="../../../danbikel/parser/lang/AbstractTraining.html#stripAugmentations(danbikel.lisp.Sexp)"><code>stripAugmentations(Sexp)</code></a>, so that argument
 augmentations that are added by <a href="../../../danbikel/parser/lang/AbstractTraining.html#identifyArguments(danbikel.lisp.Sexp)"><code>identifyArguments(Sexp)</code></a> do not
 get removed.  The default value is the symbol returned by
 <code>Symbol.add(&quot;A&quot;)</code>.  If this default value conflicts
 with an augmentation already used in a particular Treebank, this value
 should be reassigned in the constructor of a subclass.</div>
</li>
</ul>
<a name="argAugmentations">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>argAugmentations</h4>
<pre>protected&nbsp;<a href="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</a> argAugmentations</pre>
<div class="block">A list representing the set of all argument augmentations.  By default,
 this data member will be initialized to a new list containing only the
 <a href="../../../danbikel/parser/lang/AbstractTraining.html#defaultArgAugmentation">default argument augmentation</a>.
 Subclasses should add additional augmentations to this list in their
 constructors, or by invoking the <a href="../../../danbikel/parser/lang/AbstractTraining.html#createArgAugmentationsList()"><code>createArgAugmentationsList()</code></a>
 method after filling in the <a href="../../../danbikel/parser/lang/AbstractTraining.html#argContexts"><code>argContexts</code></a> map.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../danbikel/parser/lang/AbstractTraining.html#argContexts"><code>argContexts</code></a>, 
<a href="../../../danbikel/parser/lang/AbstractTraining.html#createArgAugmentationsList()"><code>createArgAugmentationsList()</code></a></dd></dl>
</li>
</ul>
<a name="traceTag">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>traceTag</h4>
<pre>protected&nbsp;<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a> traceTag</pre>
<div class="block">The symbol that gets assigned as the part of speech for null
 preterminals that represent traces that have undergone WH-movement, as
 relabeled by the default implementation of <a href="../../../danbikel/parser/lang/AbstractTraining.html#addGapInformation(danbikel.lisp.Sexp)"><code>addGapInformation(Sexp)</code></a>.  The default value is the return value of
 <code>Symbol.add(&quot;*TRACE*&quot;)</code>.  If this maps to an actual
 part of speech tag or nonterminal label in a particular Treebank, this
 data member should be reassigned in the constructor of a subclass.</div>
</li>
</ul>
<a name="canonicalAugDelimSym">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>canonicalAugDelimSym</h4>
<pre>protected final&nbsp;<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a> canonicalAugDelimSym</pre>
<div class="block">A Symbol created from the first character of <a href="../../../danbikel/parser/Treebank.html#augmentationDelimiters()"><code>Treebank.augmentationDelimiters()</code></a>.</div>
</li>
</ul>
<a name="nodesToPrune">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nodesToPrune</h4>
<pre>protected&nbsp;<a href="http://java.sun.com/javase/6/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</a> nodesToPrune</pre>
<div class="block">Data member to store the set of nodes to prune for the default
 implementation of <a href="../../../danbikel/parser/lang/AbstractTraining.html#prune(danbikel.lisp.Sexp)"><code>prune(Sexp)</code></a>.  The set should only contain
 objects of type <code>Symbol</code>, and the elements of this set
 should be added in the constructor of a subclass.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../danbikel/parser/lang/AbstractTraining.html#prune(danbikel.lisp.Sexp)"><code>prune(Sexp)</code></a></dd></dl>
</li>
</ul>
<a name="wordsToPrune">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>wordsToPrune</h4>
<pre>protected&nbsp;<a href="http://java.sun.com/javase/6/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</a> wordsToPrune</pre>
<div class="block">Data member to store the set of words to prune for the default
 implementation of <a href="../../../danbikel/parser/lang/AbstractTraining.html#prune(danbikel.lisp.Sexp)"><code>prune(Sexp)</code></a>.  The set should only contain
 objects of type <code>Symbol</code>, and the elements of this set should be
 added in the constructor of a subclass.  The default implementation will
 only prune a preterminal if both the part-of-speech tag is in <a href="../../../danbikel/parser/lang/AbstractTraining.html#nodesToPrune"><code>nodesToPrune</code></a> <i><b>and</b></i> if the word is in this
 <code>wordsToPrune</code> set.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../danbikel/parser/lang/AbstractTraining.html#prune(danbikel.lisp.Sexp)"><code>prune(Sexp)</code></a></dd></dl>
</li>
</ul>
<a name="prunedPreterms">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>prunedPreterms</h4>
<pre>protected&nbsp;<a href="http://java.sun.com/javase/6/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</a> prunedPreterms</pre>
<div class="block">The set of preterminals (<code>Sexp</code> objects) that have been pruned
 away.</div>
</li>
</ul>
<a name="argContexts">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>argContexts</h4>
<pre>protected&nbsp;<a href="http://java.sun.com/javase/6/docs/api/java/util/Map.html?is-external=true" title="class or interface in java.util">Map</a> argContexts</pre>
<div class="block">Data member used to store the map required by the default implementation
 of the method <a href="../../../danbikel/parser/lang/AbstractTraining.html#identifyArguments(danbikel.lisp.Sexp)"><code>identifyArguments(Sexp)</code></a>.  This data member maps
 parent nonterminals to lists of children nonterminals, to indicate that
 the children are candidates for being labeled as arguments in the presence
 of that parent.  A children list may also be a list of the form
 <pre>
 (head &lt;offset&gt;)
 </pre>
 indicating to match a node <code>&lt;offset&gt;</code> away from the head
 child of the parent that was mapped to this children list.  The keys and
 values of this map should be added in the constructor of a subclass.
 The keys of this map must be of type <a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp"><code>Symbol</code></a>, and the values of
 this map must be of type <a href="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp"><code>SexpList</code></a>.
 <p>
 Optionally, after this data member has been filled in by the constructor
 of a subclass, the method <a href="../../../danbikel/parser/lang/AbstractTraining.html#createArgAugmentationsList()"><code>createArgAugmentationsList()</code></a> should
 be invoked to automatically fill in the <a href="../../../danbikel/parser/lang/AbstractTraining.html#argAugmentations"><code>argAugmentations</code></a> list.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../danbikel/parser/lang/AbstractTraining.html#identifyArguments(danbikel.lisp.Sexp)"><code>identifyArguments(Sexp)</code></a>, 
<a href="../../../danbikel/parser/lang/AbstractTraining.html#argAugmentations"><code>argAugmentations</code></a>, 
<a href="../../../danbikel/parser/lang/AbstractTraining.html#createArgAugmentationsList()"><code>createArgAugmentationsList()</code></a></dd></dl>
</li>
</ul>
<a name="semTagArgStopSet">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>semTagArgStopSet</h4>
<pre>protected&nbsp;<a href="http://java.sun.com/javase/6/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</a> semTagArgStopSet</pre>
<div class="block">Data member used to store the set required by the method <a href="../../../danbikel/parser/lang/AbstractTraining.html#identifyArguments(danbikel.lisp.Sexp)"><code>identifyArguments(Sexp)</code></a>.  The set contains semantic tags (which is
 English Treebank parlance) that prohibit a candidate argument child from
 being relabeled as an argument.  The objects in this set must all be of
 type <code>Symbol</code>.  The members of this set should be added in the
 constructor of a subclass.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../danbikel/parser/lang/AbstractTraining.html#identifyArguments(danbikel.lisp.Sexp)"><code>identifyArguments(Sexp)</code></a></dd></dl>
</li>
</ul>
<a name="headSym">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>headSym</h4>
<pre>protected static final&nbsp;<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a> headSym</pre>
<div class="block">The symbol that is a possible mapping in <a href="../../../danbikel/parser/lang/AbstractTraining.html#argContexts"><code>argContexts</code></a> to indicate
 to choose a child relative to the head as an argument.  For example, an
 argument context might be <code>PP</code> mapping to <code>(head
 1))</code>, meaning that the child that is 1 position to the right of the
 head child of a PP should be relabeled as an argument.  The value of this
 data member is the symbol returned by
 <code>Symbol.add(&quot;head&quot;)</code>.  In the unlikely event that
 this value conflicts with a nonterminal in a particular Treebank, this
 data member should be reassigned in the constructor of a subclass.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../danbikel/parser/lang/AbstractTraining.html#identifyArguments(danbikel.lisp.Sexp)"><code>identifyArguments(Sexp)</code></a></dd></dl>
</li>
</ul>
<a name="headPreSym">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>headPreSym</h4>
<pre>protected static final&nbsp;<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a> headPreSym</pre>
<div class="block">The symbol that is a possible mapping <a href="../../../danbikel/parser/lang/AbstractTraining.html#argContexts"><code>argContexts</code></a> to indicate
 to choose a child relative to the left side of the head as an argument.
 For example, an argument context might be <code>VP</code> mapping to
 <code>(head-left left MD VBD)</code>, meaning that the children to the left
 of the head child should be searched from left to right, and the first
 child found that is a member of the set <tt>{MD, VBD}</tt> should be
 considered a possible argument of the head.</div>
</li>
</ul>
<a name="headPostSym">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>headPostSym</h4>
<pre>protected static final&nbsp;<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a> headPostSym</pre>
<div class="block">The symbol that is a possible mapping <a href="../../../danbikel/parser/lang/AbstractTraining.html#argContexts"><code>argContexts</code></a> to indicate
 to choose a child relative to the right side of the head as an argument.
 For example, an argument context might be <code>PP</code> mapping to
 <code>(head-right left PP NP WHNP ADJP)</code>, meaning that the children
 to the right of the head child should be searched from left to right, and
 the first child found that is a member of the set
 <tt>{PP, NP, WHNP, ADJP}</tt> should be considered a possible argument
 of the head.</div>
</li>
</ul>
<a name="baseNP">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>baseNP</h4>
<pre>protected final&nbsp;<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a> baseNP</pre>
<div class="block">The value of <a href="../../../danbikel/parser/Treebank.html#baseNPLabel()"><code>Treebank.baseNPLabel()</code></a>, cached for efficiency and
 convenience.</div>
</li>
</ul>
<a name="NP">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>NP</h4>
<pre>protected final&nbsp;<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a> NP</pre>
<div class="block">The value of <a href="../../../danbikel/parser/Treebank.html#NPLabel()"><code>Treebank.NPLabel()</code></a>, cached for efficiency and
 convenience.</div>
</li>
</ul>
<a name="prunedPunctuation">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>prunedPunctuation</h4>
<pre>protected&nbsp;<a href="http://java.sun.com/javase/6/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</a> prunedPunctuation</pre>
<div class="block">The set of preterminals (<code>Sexp</code> objects) that were "raised
 away" by <a href="../../../danbikel/parser/lang/AbstractTraining.html#raisePunctuation(danbikel.lisp.Sexp)"><code>raisePunctuation(Sexp)</code></a> because they appeared either at
 the beginning or the end of a sentence.</div>
</li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="AbstractTraining()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>AbstractTraining</h4>
<pre>protected&nbsp;AbstractTraining()</pre>
<div class="block">Default constructor for this abstract base class; sets <a href="../../../danbikel/parser/lang/AbstractTraining.html#argContexts"><code>argContexts</code></a> to a new <code>Map</code> object, sets <a href="../../../danbikel/parser/lang/AbstractTraining.html#semTagArgStopSet"><code>semTagArgStopSet</code></a> to a new <code>Set</code> object and initializes <a href="../../../danbikel/parser/lang/AbstractTraining.html#canonicalAugDelimSym"><code>canonicalAugDelimSym</code></a>.  Subclass constructors are responsible for filling
 in the data for <a href="../../../danbikel/parser/lang/AbstractTraining.html#argContexts"><code>argContexts</code></a> and <a href="../../../danbikel/parser/lang/AbstractTraining.html#semTagArgStopSet"><code>semTagArgStopSet</code></a>.</div>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="setUpFastArgMap(danbikel.parser.CountsTable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setUpFastArgMap</h4>
<pre>public&nbsp;void&nbsp;setUpFastArgMap(<a href="../../../danbikel/parser/CountsTable.html" title="interface in danbikel.parser">CountsTable</a>&nbsp;nonterminals)</pre>
<div class="block"><strong>Description copied from interface:&nbsp;<code><a href="../../../danbikel/parser/Training.html#setUpFastArgMap(danbikel.parser.CountsTable)">Training</a></code></strong></div>
<div class="block">Indicates to set up a static map for quickly mapping argument nonterminals
 to their non-argument variants (that is, for quickly stripping away
 their argument augmentations).
 <p>
 <b>N.B.</b>: This method is necessarily thread-safe, as it is expected
 to be invoked by every <a href="../../../danbikel/parser/Decoder.html" title="class in danbikel.parser"><code>Decoder</code></a> as it starts up, and since there
 can be multiple <a href="../../../danbikel/parser/Decoder.html" title="class in danbikel.parser"><code>Decoder</code></a> instances within a given VM.
 <b><i>However</i></b>, note that it is <b>inappropriate to invoke this
 method</b> if the set of nonterminals in the specified counts table
 is incomplete (see the documentation for the <a href="../../../danbikel/parser/SubcatBag.html" title="class in danbikel.parser"><code>SubcatBag</code></a> class
 for an instance where this will be the case).</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../../danbikel/parser/Training.html#setUpFastArgMap(danbikel.parser.CountsTable)">setUpFastArgMap</a></code>&nbsp;in interface&nbsp;<code><a href="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>nonterminals</code> - a counts table whose keys form a complete set of
 all possible nonterminal labels, as is obtained from
 <a href="../../../danbikel/parser/DecoderServerRemote.html#nonterminals()"><code>DecoderServerRemote.nonterminals()</code></a> (the counts to which the
 nonterminals are mapped are not used by this method)</dd></dl>
</li>
</ul>
<a name="staticSetUpFastArgMap(danbikel.parser.CountsTable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>staticSetUpFastArgMap</h4>
<pre>protected static&nbsp;void&nbsp;staticSetUpFastArgMap(<a href="../../../danbikel/parser/CountsTable.html" title="interface in danbikel.parser">CountsTable</a>&nbsp;nonterminals)</pre>
<div class="block">Indicates to set up a static map for quickly mapping argument nonterminals
 to their non-argument variants (that is, for quickly stripping away
 their argument augmentations).
 <p>
 <b>N.B.</b>: This method is necessarily thread-safe, as it is expected
 to be invoked by every <a href="../../../danbikel/parser/Decoder.html" title="class in danbikel.parser"><code>Decoder</code></a> as it starts up, and since there
 can be multiple <a href="../../../danbikel/parser/Decoder.html" title="class in danbikel.parser"><code>Decoder</code></a> instances within a given VM.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>nonterminals</code> - a counts table whose keys form a complete set of
 all possible nonterminal labels, as is obtained from
 <a href="../../../danbikel/parser/DecoderServerRemote.html#nonterminals()"><code>DecoderServerRemote.nonterminals()</code></a> (the counts to which the
 nonterminals are mapped are not used by this method)</dd></dl>
</li>
</ul>
<a name="preProcess(danbikel.lisp.Sexp)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>preProcess</h4>
<pre>public&nbsp;<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;preProcess(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</pre>
<div class="block">The method to call before counting events in a training parse tree.
 This default implementation executes the following methods of this class
 in order:
 <ol>
 <li> <a href="../../../danbikel/parser/lang/AbstractTraining.html#prune(danbikel.lisp.Sexp)"><code>prune(Sexp)</code></a>
 <li> <a href="../../../danbikel/parser/lang/AbstractTraining.html#addBaseNPs(danbikel.lisp.Sexp)"><code>addBaseNPs(Sexp)</code></a>
 <li> <a href="../../../danbikel/parser/lang/AbstractTraining.html#repairBaseNPs(danbikel.lisp.Sexp)"><code>repairBaseNPs(Sexp)</code></a>
 <li> <a href="../../../danbikel/parser/lang/AbstractTraining.html#addGapInformation(danbikel.lisp.Sexp)"><code>addGapInformation(Sexp)</code></a>
 <li> <a href="../../../danbikel/parser/lang/AbstractTraining.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)"><code>relabelSubjectlessSentences(Sexp)</code></a>
 <li> <a href="../../../danbikel/parser/lang/AbstractTraining.html#removeNullElements(danbikel.lisp.Sexp)"><code>removeNullElements(Sexp)</code></a>
 <li> <a href="../../../danbikel/parser/lang/AbstractTraining.html#raisePunctuation(danbikel.lisp.Sexp)"><code>raisePunctuation(Sexp)</code></a>
 <li> <a href="../../../danbikel/parser/lang/AbstractTraining.html#identifyArguments(danbikel.lisp.Sexp)"><code>identifyArguments(Sexp)</code></a>
 <li> <a href="../../../danbikel/parser/lang/AbstractTraining.html#stripAugmentations(danbikel.lisp.Sexp)"><code>stripAugmentations(Sexp)</code></a>
 </ol>
 While every attempt has been made to make the default implementations of
 these preprocessing methods independent of one another, the order above is
 not entirely arbitrary.  In particular:
 <ul>
 <li><a href="../../../danbikel/parser/lang/AbstractTraining.html#addGapInformation(danbikel.lisp.Sexp)"><code>addGapInformation(Sexp)</code></a> should be run after methods that
 introduce new nodes, which in this case is <a href="../../../danbikel/parser/lang/AbstractTraining.html#addBaseNPs(danbikel.lisp.Sexp)"><code>addBaseNPs(Sexp)</code></a>, as
 these new nodes may need to be used to thread the gap feature
 <li><a href="../../../danbikel/parser/lang/AbstractTraining.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)"><code>relabelSubjectlessSentences(Sexp)</code></a> should be run after
 <a href="../../../danbikel/parser/lang/AbstractTraining.html#addGapInformation(danbikel.lisp.Sexp)"><code>addGapInformation(Sexp)</code></a> because only those sentences whose
 empty subjects are <i>not</i> the result of WH-movement should be
 relabeled
 <li><a href="../../../danbikel/parser/lang/AbstractTraining.html#removeNullElements(danbikel.lisp.Sexp)"><code>removeNullElements(Sexp)</code></a> should be run after any
 methods that depend on the presence of null elements, such as
   <ul>
   <li><a href="../../../danbikel/parser/lang/AbstractTraining.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)"><code>relabelSubjectlessSentences(Sexp)</code></a> because a sentence cannot
   be determined to be subjectless unless a null element is present as
   a child of a subject-marked node
   <br>and<br>
   <li><a href="../../../danbikel/parser/lang/AbstractTraining.html#addGapInformation(danbikel.lisp.Sexp)"><code>addGapInformation(Sexp)</code></a> because the determination of
   the location of a trace requires the presence of indexed null elements
   </ul>
 <li><a href="../../../danbikel/parser/lang/AbstractTraining.html#raisePunctuation(danbikel.lisp.Sexp)"><code>raisePunctuation(Sexp)</code></a> should be run after
 <a href="../../../danbikel/parser/lang/AbstractTraining.html#removeNullElements(danbikel.lisp.Sexp)"><code>removeNullElements(Sexp)</code></a> because a null element that is a
 leftmost or rightmost child can block detection of a punctuation element
 that needs to be raised after removal of the null element (if a punctuation
 element is the next-to-leftmost or next-to-rightmost child of an interior
 node)
 <li><a href="../../../danbikel/parser/lang/AbstractTraining.html#stripAugmentations(danbikel.lisp.Sexp)"><code>stripAugmentations(Sexp)</code></a> should be run after all methods
 that may depend upon the presence of nonterminal augmentations: <a href="../../../danbikel/parser/lang/AbstractTraining.html#identifyArguments(danbikel.lisp.Sexp)"><code>identifyArguments(Sexp)</code></a>, <a href="../../../danbikel/parser/lang/AbstractTraining.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)"><code>relabelSubjectlessSentences(Sexp)</code></a> and
 <a href="../../../danbikel/parser/lang/AbstractTraining.html#addGapInformation(danbikel.lisp.Sexp)"><code>addGapInformation(Sexp)</code></a>
 </ul></div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../../danbikel/parser/Training.html#preProcess(danbikel.lisp.Sexp)">preProcess</a></code>&nbsp;in interface&nbsp;<code><a href="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>tree</code> - the parse tree to pre-process</dd>
<dt><span class="strong">Returns:</span></dt><dd><code>tree</code> having been pre-processed</dd></dl>
</li>
</ul>
<a name="removeWord(danbikel.lisp.Symbol, danbikel.lisp.Symbol, int, danbikel.lisp.SexpList, danbikel.lisp.SexpList, danbikel.lisp.SexpList, java.util.Set, java.util.Map)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>removeWord</h4>
<pre>public&nbsp;boolean&nbsp;removeWord(<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;word,
                 <a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;tag,
                 int&nbsp;idx,
                 <a href="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</a>&nbsp;sentence,
                 <a href="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</a>&nbsp;tags,
                 <a href="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</a>&nbsp;originalTags,
                 <a href="http://java.sun.com/javase/6/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</a>&nbsp;prunedPretermsPosSet,
                 <a href="http://java.sun.com/javase/6/docs/api/java/util/Map.html?is-external=true" title="class or interface in java.util">Map</a>&nbsp;prunedPretermsPosMap)</pre>
<div class="block"><strong>Description copied from interface:&nbsp;<code><a href="../../../danbikel/parser/Training.html#removeWord(danbikel.lisp.Symbol,%20danbikel.lisp.Symbol,%20int,%20danbikel.lisp.SexpList,%20danbikel.lisp.SexpList,%20danbikel.lisp.SexpList,%20java.util.Set,%20java.util.Map)">Training</a></code></strong></div>
<div class="block">Invoked by the <a href="../../../danbikel/parser/Decoder.html" title="class in danbikel.parser">decoder</a> as the first
 step in preprocessing (prior to the invocation of <a href="../../../danbikel/parser/Training.html#preProcessTest(danbikel.lisp.SexpList,%20danbikel.lisp.SexpList,%20danbikel.lisp.SexpList)"><code>Training.preProcessTest(danbikel.lisp.SexpList, danbikel.lisp.SexpList, danbikel.lisp.SexpList)</code></a>).
 Returns whether the specified word should be removed from the sentence
 before parsing.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../../danbikel/parser/Training.html#removeWord(danbikel.lisp.Symbol,%20danbikel.lisp.Symbol,%20int,%20danbikel.lisp.SexpList,%20danbikel.lisp.SexpList,%20danbikel.lisp.SexpList,%20java.util.Set,%20java.util.Map)">removeWord</a></code>&nbsp;in interface&nbsp;<code><a href="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>word</code> - a word in the sentence about to parsed</dd><dd><code>tag</code> - the supplied part-of-speech tag of the specified word,
 or <tt>null</tt> if tags were not supplied</dd><dd><code>idx</code> - the index of the specified word in the specified sentence</dd><dd><code>sentence</code> - a list of <a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp"><code>Symbol</code></a> objects that represent the words
 of the sentence to be parsed</dd><dd><code>tags</code> - coordinated list of supplied part-of-speech tag lists for each
 of the words in the specified sentence, or <tt>null</tt> if no tags
 were supplied</dd><dd><code>originalTags</code> - the cached copy of the specified <tt>tags</tt> list,
 used when <a href="../../../danbikel/parser/Settings.html#restorePrunedWords"><code>Settings.restorePrunedWords</code></a> is <tt>true</tt></dd><dd><code>prunedPretermsPosSet</code> - the set of part-of-speech tags that were
 pruned during training</dd><dd><code>prunedPretermsPosMap</code> - a map of words pruned during training to
 their part-of-speech tags when they were pruned</dd>
<dt><span class="strong">Returns:</span></dt><dd>whether the specified word should be removed from the sentence
 before parsing</dd></dl>
</li>
</ul>
<a name="preProcessTest(danbikel.lisp.SexpList, danbikel.lisp.SexpList, danbikel.lisp.SexpList)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>preProcessTest</h4>
<pre>public&nbsp;<a href="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</a>&nbsp;preProcessTest(<a href="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</a>&nbsp;sentence,
                      <a href="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</a>&nbsp;originalWords,
                      <a href="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</a>&nbsp;tags)</pre>
<div class="block">Preprocesses the specified test sentence and its coordinated list of tags.
 The default implementation here does nothing.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../../danbikel/parser/Training.html#preProcessTest(danbikel.lisp.SexpList,%20danbikel.lisp.SexpList,%20danbikel.lisp.SexpList)">preProcessTest</a></code>&nbsp;in interface&nbsp;<code><a href="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>sentence</code> - the list of words, where a known word is a symbol and
 an unknown word is represented by a 3-element list (see
 <a href="../../../danbikel/parser/DecoderServerRemote.html#convertUnknownWords(danbikel.lisp.SexpList)"><code>DecoderServerRemote.convertUnknownWords(danbikel.lisp.SexpList)</code></a>)</dd><dd><code>originalWords</code> - the list of unprocessed words (all symbols)</dd><dd><code>tags</code> - the list of tag lists, where the list at index <i>i</i>
 is the list of possible parts of speech for the word at that index</dd>
<dt><span class="strong">Returns:</span></dt><dd>a two-element list, containing two lists, the first of which
 is a processed version of <code>sentence</code> and the second of which
 is a processed version of <code>tags</code>; if <code>tags</code>
 is <code>null</code>, then the returned list will contain only
 one element (since <code>SexpList</code> objects are not designed
 to handle null elements)</dd></dl>
</li>
</ul>
<a name="isValidTree(danbikel.lisp.Sexp)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isValidTree</h4>
<pre>public&nbsp;boolean&nbsp;isValidTree(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</pre>
<div class="block">Returns <code>true</code> if <code>tree</code> is a preterminal (the base
 case) or is a list with the first element of type <code>Symbol</code> (the
 node label) and subsequent elements are valid trees (the recursive case).
 If a language package requires a different definition of training parse
 tree validity, this method should be overridden.  However, changing the
 definition of tree validity should be done with care, as the default
 implementations of the tree-processing methods in this class require trees
 that correspond to the definition of validity implemented by this method.
 This method also ensures that not all words or preterminals in the tree
 are to be pruned.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../../danbikel/parser/Training.html#isValidTree(danbikel.lisp.Sexp)">isValidTree</a></code>&nbsp;in interface&nbsp;<code><a href="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>tree</code> - the parse tree to check for validity</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../../danbikel/parser/lang/AbstractTraining.html#isAllNodesToPrune(danbikel.lisp.Sexp)"><code>isAllNodesToPrune(Sexp)</code></a>, 
<a href="../../../danbikel/parser/Treebank.html#isPreterminal(danbikel.lisp.Sexp)"><code>Treebank.isPreterminal(Sexp)</code></a></dd></dl>
</li>
</ul>
<a name="isAllNodesToPrune(danbikel.lisp.Sexp)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isAllNodesToPrune</h4>
<pre>public&nbsp;boolean&nbsp;isAllNodesToPrune(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</pre>
<div class="block">Returns whether all words or preterminals of this tree are to be pruned.
 For example, if the part-of-speech tag "." is a <a href="../../../danbikel/parser/lang/AbstractTraining.html#nodesToPrune">node to prune</a> and the word "rubbish" is a <a href="../../../danbikel/parser/lang/AbstractTraining.html#wordsToPrune">word to prune</a> and the specified tree is <tt>(S (NN rubbish) (. .))</tt>
 then this method will return <tt>true</tt>.  If <tt>S</tt>
 is a <a href="../../../danbikel/parser/lang/AbstractTraining.html#nodesToPrune">node to prune</a>, then this method
 will return <tt>true</tt> for the tree <tt>(S (NN rubbish) (. .))</tt>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>tree</code> - the tree to inspect</dd>
<dt><span class="strong">Returns:</span></dt><dd>whether all nodes of this tree are to be pruned.</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../../danbikel/parser/lang/AbstractTraining.html#prune(danbikel.lisp.Sexp)"><code>prune(Sexp)</code></a></dd></dl>
</li>
</ul>
<a name="skip(danbikel.lisp.Sexp)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>skip</h4>
<pre>public&nbsp;<a href="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;skip(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</pre>
<div class="block">Returns whether the specified tree is to be skipped when training.
 The default implementation here simply returns the negation of the
 return value of <a href="../../../danbikel/parser/lang/AbstractTraining.html#isValidTree(danbikel.lisp.Sexp)"><code>isValidTree(Sexp)</code></a>.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../../danbikel/parser/Training.html#skip(danbikel.lisp.Sexp)">skip</a></code>&nbsp;in interface&nbsp;<code><a href="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>tree</code> - an annotated training tree</dd>
<dt><span class="strong">Returns:</span></dt><dd>a string if the specified tree is to be skipped
 when training, <code>null</code> otherwise</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../../danbikel/parser/Trainer.html#train(danbikel.lisp.SexpTokenizer,%20boolean,%20boolean)"><code>Trainer.train(SexpTokenizer,boolean,boolean)</code></a></dd></dl>
</li>
</ul>
<a name="transformSubjectNTs(danbikel.lisp.Sexp)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>transformSubjectNTs</h4>
<pre>public&nbsp;<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;transformSubjectNTs(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</pre>
<div class="block">Transforms nonterminals marked with a subject augmentation so that their
 unaugmented base label is the concatenation of the original base label
 plus the subject augmentation.  For example, transforms <tt>NP-SBJ-1</tt>
 to <tt>NP-SBJ</tt>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>tree</code> - the tree in which to transform subject nonterminals</dd>
<dt><span class="strong">Returns:</span></dt><dd>the specified tree but with subject nonterminals transformed
 to remove separators between their base labels and their subject
 augmentations</dd></dl>
</li>
</ul>
<a name="getPrunedPreterms()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPrunedPreterms</h4>
<pre>public&nbsp;<a href="http://java.sun.com/javase/6/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</a>&nbsp;getPrunedPreterms()</pre>
<div class="block">Returns the set of pruned preterminals (<code>Sexp</code> objects).</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../../danbikel/parser/Training.html#getPrunedPreterms()">getPrunedPreterms</a></code>&nbsp;in interface&nbsp;<code><a href="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</a></code></dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="../../../danbikel/parser/lang/AbstractTraining.html#prune(danbikel.lisp.Sexp)"><code>prune(Sexp)</code></a></dd></dl>
</li>
</ul>
<a name="prune(danbikel.lisp.Sexp)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>prune</h4>
<pre>public&nbsp;<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;prune(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</pre>
<div class="block">Prunes away subtrees that have a root that is an element of
 <code>nodesToPrune</code>.
 <p>
 <b>Side effect</b>: An internal set of pruned preterminals will
 be updated.  This set may be accessed via <a href="../../../danbikel/parser/lang/AbstractTraining.html#getPrunedPreterms()"><code>getPrunedPreterms()</code></a>.
 <p>
 <b>Bugs</b>: Cannot prune away entire tree if the root label of the
 specified tree is in <code>nodesToPrune</code>.
 <p></div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../../danbikel/parser/Training.html#prune(danbikel.lisp.Sexp)">prune</a></code>&nbsp;in interface&nbsp;<code><a href="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>tree</code> - the parse tree to prune</dd>
<dt><span class="strong">Returns:</span></dt><dd><code>tree</code> having been pruned</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../../danbikel/parser/lang/AbstractTraining.html#nodesToPrune"><code>nodesToPrune</code></a></dd></dl>
</li>
</ul>
<a name="collectPreterms(java.util.Set, danbikel.lisp.Sexp)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>collectPreterms</h4>
<pre>protected final&nbsp;void&nbsp;collectPreterms(<a href="http://java.sun.com/javase/6/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</a>&nbsp;preterms,
                   <a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</pre>
<div class="block">Adds all preterminal subtrees to the specified set.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>preterms</code> - the set to which preterminal subtrees of the specified
 tree are to be added</dd><dd><code>tree</code> - the tree from which to collect preterminal subtrees</dd></dl>
</li>
</ul>
<a name="identifyArguments(danbikel.lisp.Sexp)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>identifyArguments</h4>
<pre>public&nbsp;<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;identifyArguments(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</pre>
<div class="block">Augments labels of nonterminals that are arguments.  This method is
 optional, and may be overridden to simply return <code>tree</code>
 untouched if argument identification is not desired for a particular
 language package.
 <p>
 Note that children in a coordinated phrase are never relabeled as
 arguments, as determined by subtrees for which
 <a href="../../../danbikel/parser/lang/AbstractTraining.html#isCoordinatedPhrase(danbikel.lisp.Sexp,%20int)"><code>isCoordinatedPhrase(Sexp,int)</code></a> returns <code>true</code>.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../../danbikel/parser/Training.html#identifyArguments(danbikel.lisp.Sexp)">identifyArguments</a></code>&nbsp;in interface&nbsp;<code><a href="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>tree</code> - the parse tree to modify</dd>
<dt><span class="strong">Returns:</span></dt><dd>a reference to the modified <code>tree</code> object</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../../danbikel/parser/Treebank.html#canonicalAugDelimiter()"><code>Treebank.canonicalAugDelimiter()</code></a></dd></dl>
</li>
</ul>
<a name="relabelArgChildren(danbikel.lisp.SexpList, int, danbikel.lisp.SexpList)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>relabelArgChildren</h4>
<pre>protected&nbsp;void&nbsp;relabelArgChildren(<a href="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</a>&nbsp;treeList,
                      int&nbsp;headIdx,
                      <a href="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</a>&nbsp;candidatePatterns)</pre>
<div class="block">Relabels as arguments all immediately-dominated children in the specified
 subtree accoding to the specified argument-finding patterns.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>treeList</code> - the subtree in which to relabel arguments</dd><dd><code>headIdx</code> - the index of the child of the specified subtree
                          that is the head</dd><dd><code>candidatePatterns</code> - the set of argument-finding rules</dd></dl>
</li>
</ul>
<a name="addArgAugmentation(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addArgAugmentation</h4>
<pre>protected&nbsp;boolean&nbsp;addArgAugmentation(<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label,
                         <a href="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</a>&nbsp;nonterminal)</pre>
<div class="block">Adds the default argument augmentation to the specified nonterminal
 if the specified label is not already an argument.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>label</code> - the label that has been parsed into the specified
 <a href="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser"><code>Nonterminal</code></a> object</dd><dd><code>nonterminal</code> - the parsed version of the specified label</dd>
<dt><span class="strong">Returns:</span></dt><dd><tt>true</tt> if the specified <a href="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser"><code>Nonterminal</code></a> object
 was modified, <tt>false</tt> otherwise</dd></dl>
</li>
</ul>
<a name="defaultArgAugmentation()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>defaultArgAugmentation</h4>
<pre>public&nbsp;<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;defaultArgAugmentation()</pre>
<div class="block">The symbol that is used to mark argument (required) nonterminals by
 <a href="../../../danbikel/parser/lang/AbstractTraining.html#identifyArguments(danbikel.lisp.Sexp)"><code>identifyArguments(Sexp)</code></a>.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../../danbikel/parser/Training.html#defaultArgAugmentation()">defaultArgAugmentation</a></code>&nbsp;in interface&nbsp;<code><a href="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</a></code></dd>
</dl>
</li>
</ul>
<a name="getCanonicalArg(danbikel.lisp.Symbol)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getCanonicalArg</h4>
<pre>public&nbsp;<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;getCanonicalArg(<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label)</pre>
<div class="block">Returns the canonical version of the specified argument nonterminal. The
 default implementation here takes the base of the (possibly compelx)
 nonterminal label and converts it via <a href="../../../danbikel/parser/Treebank.html#getCanonical(danbikel.lisp.Symbol)"><code>Treebank.getCanonical(Symbol)</code></a>.
 For example, in the English Penn Treebank, <tt>S</tt> nonterminals that
 dominate trees with no subjects get converted to <tt>SG</tt>; if one of
 these is identified as an argument, it will be converted to <tt>SG-A</tt>;
 this method will return <tt>S-A</tt>, since <tt>S</tt> is the canonical
 version of <tt>SG</tt>.  This method is needed by the class <a href="../../../danbikel/parser/SubcatBag.html" title="class in danbikel.parser"><code>SubcatBag</code></a>.
 <br>
 <b>Implementation note</b>: This method uses an internal
 cache to perform argument label canonicalizations in O(1) expected time.
 For cache misses the actual canonicalization is handled by the <a href="../../../danbikel/parser/lang/AbstractTraining.html#getCanonicalArg(danbikel.lisp.Symbol,%20danbikel.parser.Nonterminal)"><code>getCanonicalArg(Symbol,Nonterminal)</code></a> method.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../../danbikel/parser/Training.html#getCanonicalArg(danbikel.lisp.Symbol)">getCanonicalArg</a></code>&nbsp;in interface&nbsp;<code><a href="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>label</code> - the argument nonterminal label to be canonicalized</dd>
<dt><span class="strong">Returns:</span></dt><dd>the canonical version of the sepcified argument label</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../../danbikel/parser/lang/AbstractTraining.html#getCanonicalArg(danbikel.lisp.Symbol,%20danbikel.parser.Nonterminal)"><code>getCanonicalArg(Symbol, Nonterminal)</code></a></dd></dl>
</li>
</ul>
<a name="getCanonicalArg(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getCanonicalArg</h4>
<pre>public&nbsp;<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;getCanonicalArg(<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label,
                     <a href="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</a>&nbsp;nonterminal)</pre>
<div class="block">Returns the canonical version of the specified argument nonterminal. The
 default implementation here takes the base of the (possibly compelx)
 nonterminal label and converts it via <a href="../../../danbikel/parser/Treebank.html#getCanonical(danbikel.lisp.Symbol)"><code>Treebank.getCanonical(Symbol)</code></a>.
  For example, in the English Penn Treebank, <tt>S</tt> nonterminals that
 dominate trees with no subjects get converted to <tt>SG</tt>; if one of
 these is identified as an argument, it will be converted to <tt>SG-A</tt>;
 this method will return <tt>S-A</tt>, since <tt>S</tt> is the canonical
 version of <tt>SG</tt>.  This method is needed by the class <a href="../../../danbikel/parser/SubcatBag.html" title="class in danbikel.parser"><code>SubcatBag</code></a>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>label</code> - the argument nonterminal label whose canonical version is
 to be returned</dd><dd><code>nonterminal</code> - the <a href="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser"><code>Nonterminal</code></a> instance to be used</dd>
<dt><span class="strong">Returns:</span></dt><dd>the canonical version of the specified argument label</dd></dl>
</li>
</ul>
<a name="isArgument(danbikel.lisp.Symbol)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isArgument</h4>
<pre>public&nbsp;boolean&nbsp;isArgument(<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label)</pre>
<div class="block">Returns <code>true</code> if and only if <code>label</code> has an
 argument augmentation as added by <a href="../../../danbikel/parser/lang/AbstractTraining.html#identifyArguments(danbikel.lisp.Sexp)"><code>identifyArguments(Sexp)</code></a>.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../../danbikel/parser/Training.html#isArgument(danbikel.lisp.Symbol)">isArgument</a></code>&nbsp;in interface&nbsp;<code><a href="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</a></code></dd>
</dl>
</li>
</ul>
<a name="isArgument(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isArgument</h4>
<pre>protected&nbsp;boolean&nbsp;isArgument(<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label,
                 <a href="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</a>&nbsp;nonterminal)</pre>
<div class="block">Returns <code>true</code> if the specified nonterminal label has an
 argument augmentation.  This method is a synonym for
 <tt>isArgument(label, nonterminal, true)</tt>.
 <br>
 <b>Implementation note</b>: This method is <i>not</i> thread-safe;
 for a thread-safe method, please use <a href="../../../danbikel/parser/lang/AbstractTraining.html#isArgumentFast(danbikel.lisp.Symbol)"><code>isArgumentFast(Symbol)</code></a>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>label</code> - the label to be tested</dd><dd><code>nonterminal</code> - the <a href="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser"><code>Nonterminal</code></a> instance to be used for
 storing the parsed version of the specified nonterminal label</dd>
<dt><span class="strong">Returns:</span></dt><dd>whether the specified nonterminal label has an argument
 augmentation</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../../danbikel/parser/lang/AbstractTraining.html#isArgument(danbikel.lisp.Symbol,%20danbikel.parser.Nonterminal,%20boolean)"><code>isArgument(Symbol,Nonterminal,boolean)</code></a></dd></dl>
</li>
</ul>
<a name="isArgument(danbikel.lisp.Symbol, danbikel.parser.Nonterminal, boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isArgument</h4>
<pre>protected&nbsp;boolean&nbsp;isArgument(<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label,
                 <a href="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</a>&nbsp;nonterminal,
                 boolean&nbsp;parseLabel)</pre>
<div class="block">Returns <code>true</code> if the specified nonterminal label has an
 argument augmentation.
 <br>
 <b>Implementation note</b>: This method is <i>not</i> thread-safe;
 for a thread-safe method, please use <a href="../../../danbikel/parser/lang/AbstractTraining.html#isArgumentFast(danbikel.lisp.Symbol)"><code>isArgumentFast(Symbol)</code></a>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>label</code> - the label to be tested</dd><dd><code>nonterminal</code> - the <a href="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser"><code>Nonterminal</code></a> instance to be used for
 storing the parsed version of the specified nonterminal label</dd><dd><code>parseLabel</code> - indicates whether to parse the specified label
 before checking whether it is an argument</dd>
<dt><span class="strong">Returns:</span></dt><dd>whether the specified nonterminal label has an argument
 augmentation</dd></dl>
</li>
</ul>
<a name="isArgumentFast(danbikel.lisp.Symbol)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isArgumentFast</h4>
<pre>public&nbsp;boolean&nbsp;isArgumentFast(<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label)</pre>
<div class="block">Returns <code>true</code> if the specified nonterminal label has an
 argument augmentation.<br>
 <b>Implementation note</b>: Unlike <a href="../../../danbikel/parser/lang/AbstractTraining.html#isArgument(danbikel.lisp.Symbol)"><code>isArgument(Symbol)</code></a>, this
 method is thread-safe.  Also, after <a href="../../../danbikel/parser/lang/AbstractTraining.html#setUpFastArgMap(danbikel.parser.CountsTable)"><code>setUpFastArgMap(CountsTable)</code></a>
 has been invoked, this method is much more efficient than
 <a href="../../../danbikel/parser/lang/AbstractTraining.html#isArgument(danbikel.lisp.Symbol)"><code>isArgument(Symbol)</code></a>, as it uses an internal cache for O(1)
 expected time operation.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../../danbikel/parser/Training.html#isArgumentFast(danbikel.lisp.Symbol)">isArgumentFast</a></code>&nbsp;in interface&nbsp;<code><a href="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</a></code></dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="../../../danbikel/parser/lang/AbstractTraining.html#setUpFastArgMap(danbikel.parser.CountsTable)"><code>setUpFastArgMap(CountsTable)</code></a></dd></dl>
</li>
</ul>
<a name="addGapInformation(danbikel.lisp.Sexp)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addGapInformation</h4>
<pre>public&nbsp;<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;addGapInformation(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</pre>
<div class="block">Augments nonterminals to include gap information for WHNP's that have
 moved and leave traces (gaps), as in the GPSG framework.  This method is
 optional, and may simply return <code>tree</code> untouched if gap
 information is desired for a particular language package.  The default
 implementation of this method checks the setting of the property <a href="../../../danbikel/parser/Settings.html#addGapInfo"><code>Settings.addGapInfo</code></a>: if this property is <code>false</code>, then
 <code>tree</code> is returned untouched; otherwise, this method simply
 calls <a href="../../../danbikel/parser/lang/AbstractTraining.html#hasGap(danbikel.lisp.Sexp,%20danbikel.lisp.Sexp,%20java.util.ArrayList)"><code>hasGap(Sexp,Sexp,ArrayList)</code></a>.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../../danbikel/parser/Training.html#addGapInformation(danbikel.lisp.Sexp)">addGapInformation</a></code>&nbsp;in interface&nbsp;<code><a href="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>tree</code> - the parse tree to which to add gapping</dd>
<dt><span class="strong">Returns:</span></dt><dd>the same <code>tree</code> that was passed in, with certain
 nodes modified to include gap information</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../../danbikel/parser/lang/AbstractTraining.html#hasGap(danbikel.lisp.Sexp,%20danbikel.lisp.Sexp,%20java.util.ArrayList)"><code>hasGap(Sexp, Sexp, ArrayList)</code></a></dd></dl>
</li>
</ul>
<a name="hasGap(danbikel.lisp.Sexp, danbikel.lisp.Sexp, java.util.ArrayList)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasGap</h4>
<pre>protected&nbsp;int&nbsp;hasGap(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree,
         <a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;root,
         <a href="http://java.sun.com/javase/6/docs/api/java/util/ArrayList.html?is-external=true" title="class or interface in java.util">ArrayList</a>&nbsp;indexStack)</pre>
<div class="block">Returns -1 if <code>tree</code> has no gap (trace), or the index of the
 trace otherwise.  If <code>tree</code> is a null preterminal with an
 indexed terminal (a trace) that matches the index at the top of
 <code>indexStack</code>, then that index is popped off the stack, the
 preterminal label is changed to be <a href="../../../danbikel/parser/lang/AbstractTraining.html#traceTag"><code>traceTag</code></a>, and the index of the
 trace is returned.  If a child of <code>tree</code> has a gap but another
 child is a WHNP that is coindexed, then the gap is &quot;filled&quot;, and
 this method returns -1; otherwise, this method augments the label of
 <code>tree</code> with <a href="../../../danbikel/parser/lang/AbstractTraining.html#gapAugmentation"><code>gapAugmentation</code></a> and returns the gap index
 of the child.
 <p>
 Put informally, this method does a depth-first search of <code>tree</code>,
 pushing the indices of any indexed WHNP nodes onto <code>indexStack</code>
 and popping off those indices when the corresponding null element is found
 someplace deeper in the tree.  The stack is necessary to allow for
 the nesting of gaps in a tree.
 <p>
 <b>Algorithm</b>:
 <pre>
 <font color=red>// base case</font>
 <b>if</b> tree is a null-element preterminal with an index that matches top of
    indexStack
 <b>then</b>
   modify preterminal to be traceTag;
   <b>return</b> pop(indexStack);
 <b>endif</b>

 <b>int</b> numWHNPChildren = 0;
 <b>Sexp</b> whnpChild = <b>null</b>;
 <b>foreach</b> child <b>of</b> tree <b>do</b>
   <b>if</b> child is a WHNP with an index augmentation <b>then</b>
     <b>if</b> numWHNPChildren == 0 <b>then</b>
       whnpChild = child;
     <b>endif</b>
     numWHNPChildren++;
   <b>endif</b>
 <b>end</b>

 <b>if</b> numWHNPChildren &gt; 0 <b>then</b>
   push(index of whnpChild, indexStack);
 <b>endif</b>

 <b>int</b> numTracesToBeLinked = 0, traceIndex = -1;
 <b>foreach</b> child <b>of</b> tree <b>do</b>
   <b>int</b> gapIndex = hasGap(child, root, indexStack); <font color=red>// recursive call</font>
   <b>if</b> gapIndex != -1 <b>then</b>
     <b>if</b> numTracesToBeLinked == 0 <b>then</b>
       traceIndex = gapIndex;
     <b>endif</b>
     numTracesToBeLinked++;
   <b>endif</b>
 <b>end</b>

 <b>if</b> numTracesToBeLinked &gt; 0 <b>then</b>
   add gap augmentation to the current parent (the root of <b>tree</b>);
   <b>if</b> numWHNPChildren &gt; 0 <b>and</b> index of whnpChild == traceIndex <b>then</b>
     <font color=red>// a trace from a child subtree has been hooked up with the current WHNP child</font>
     <b>return</b> -1;
   <b>else</b>
     <b>return</b> traceIndex;
   <b>endif</b>
 <b>else</b>
   <b>if</b> numWHNPChildren &gt; 0 <b>then</b>
     <b>print</b> warning that a moved WHNP node doesn't have a coindexed trace
       in any of its parent's other child subtrees;
   <b>endif</b>
   <b>return</b> -1;
 <b>endif</b>
 </pre>
 A warning will also be issued if there are crossing WHNP-trace
 dependencies.
 <p>
 This method is called by the default implementation of <a href="../../../danbikel/parser/lang/AbstractTraining.html#addGapInformation(danbikel.lisp.Sexp)"><code>addGapInformation(danbikel.lisp.Sexp)</code></a>.
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>tree</code> - the tree to gapify</dd><dd><code>root</code> - always the root of the tree we're gapifying, for error and
 warning reporting</dd><dd><code>indexStack</code> - a stack of <code>Integer</code> objects (where the top
 of the stack is the highest-indexed object), representing the pending
 requests to find traces to match with coindexed WHNP's discovered higher
 up in the tree (earlier in the DFS)</dd>
<dt><span class="strong">Returns:</span></dt><dd>-1 if <code>tree</code> has no gap, or the index of the trace
 otherwise</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../../danbikel/parser/lang/AbstractTraining.html#gapAugmentation"><code>gapAugmentation</code></a>, 
<a href="../../../danbikel/parser/lang/AbstractTraining.html#traceTag"><code>traceTag</code></a>, 
<a href="../../../danbikel/parser/lang/AbstractTraining.html#addGapInformation(danbikel.lisp.Sexp)"><code>addGapInformation(Sexp)</code></a>, 
<a href="../../../danbikel/parser/Treebank.html#isWHNP(danbikel.lisp.Symbol)"><code>Treebank.isWHNP(Symbol)</code></a>, 
<a href="../../../danbikel/parser/Treebank.html#isNullElementPreterminal(danbikel.lisp.Sexp)"><code>Treebank.isNullElementPreterminal(Sexp)</code></a>, 
<a href="../../../danbikel/parser/Treebank.html#getTraceIndex(danbikel.lisp.Sexp,%20danbikel.parser.Nonterminal)"><code>Treebank.getTraceIndex(Sexp, Nonterminal)</code></a></dd></dl>
</li>
</ul>
<a name="hasGap(danbikel.lisp.Symbol)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasGap</h4>
<pre>public&nbsp;boolean&nbsp;hasGap(<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label)</pre>
<div class="block">Returns <code>true</code> if and only if <code>label</code> has a
 gap augmentation as added by <a href="../../../danbikel/parser/lang/AbstractTraining.html#addGapInformation(danbikel.lisp.Sexp)"><code>addGapInformation(Sexp)</code></a>.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../../danbikel/parser/Training.html#hasGap(danbikel.lisp.Symbol)">hasGap</a></code>&nbsp;in interface&nbsp;<code><a href="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</a></code></dd>
</dl>
</li>
</ul>
<a name="gapAugmentation()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>gapAugmentation</h4>
<pre>public&nbsp;<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;gapAugmentation()</pre>
<div class="block">The symbol that will be used to identify nonterminals whose subtrees
 contain a gap (a trace).  This method is used by <a href="../../../danbikel/parser/lang/AbstractTraining.html#stripAugmentations(danbikel.lisp.Sexp)"><code>stripAugmentations(Sexp)</code></a>, so that gap augmentations that are added by
 <a href="../../../danbikel/parser/lang/AbstractTraining.html#addGapInformation(danbikel.lisp.Sexp)"><code>addGapInformation(Sexp)</code></a> do not get removed.  The default value is
 the symbol returned by <code>Symbol.add(&quot;g&quot;)</code>.  If this
 default value conflicts with an augmentation already used in a particular
 Treebank, the value of the data member <a href="../../../danbikel/parser/lang/AbstractTraining.html#gapAugmentation"><code>gapAugmentation</code></a> should be
 reassigned in the constructor of a subclass.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../../danbikel/parser/Training.html#gapAugmentation()">gapAugmentation</a></code>&nbsp;in interface&nbsp;<code><a href="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</a></code></dd>
</dl>
</li>
</ul>
<a name="traceTag()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>traceTag</h4>
<pre>public&nbsp;<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;traceTag()</pre>
<div class="block">The symbol that gets reassigned as the part of speech for null
 preterminals that represent traces that have undergone WH-movement, as
 relabeled by the default implementation of <a href="../../../danbikel/parser/lang/AbstractTraining.html#addGapInformation(danbikel.lisp.Sexp)"><code>addGapInformation(Sexp)</code></a>.  The default value is the return value of
 <code>Symbol.add(&quot;*TRACE*&quot;)</code>.  If this maps to an actual
 part of speech tag or nonterminal label in a particular Treebank, the
 data member <a href="../../../danbikel/parser/lang/AbstractTraining.html#traceTag"><code>traceTag</code></a> should be reassigned in the constructor
 of a subclass.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../../danbikel/parser/Training.html#traceTag()">traceTag</a></code>&nbsp;in interface&nbsp;<code><a href="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</a></code></dd>
</dl>
</li>
</ul>
<a name="relabelSubjectlessSentences(danbikel.lisp.Sexp)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>relabelSubjectlessSentences</h4>
<pre>public&nbsp;<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;relabelSubjectlessSentences(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</pre>
<div class="block">Relabels sentences that have no subjects with the nonterminal label
 returned by <a href="../../../danbikel/parser/Treebank.html#subjectlessSentenceLabel()"><code>Treebank.subjectlessSentenceLabel()</code></a>.  This method is
 optional, and may be overridden to simply return <code>tree</code>
 untouched if subjectless sentence relabeling is not desired for a
 particular language package.
 <p>
 The default implementation here assumes that a subjectless sentence is a
 node for which <a href="../../../danbikel/parser/Treebank.html#isSentence(danbikel.lisp.Symbol)"><code>Treebank.isSentence(Symbol)</code></a> returns
 <code>true</code> and has a child with an augmentation for which <a href="../../../danbikel/parser/Treebank.html#subjectAugmentation()"><code>Treebank.subjectAugmentation()</code></a> returns <code>true</code>, and that this
 child represents a subtree that is a series of unary productions, ending in
 a subtree for which <a href="../../../danbikel/parser/Treebank.html#isNullElementPreterminal(danbikel.lisp.Sexp)"><code>Treebank.isNullElementPreterminal(Sexp)</code></a>
 returns <code>true</code>.  Informally, this method looks for sentence
 nodes that have a child marked as a subject, where that child has a null
 element as its first (and presumably only) child.  For example, in the
 English Treebank, this would mean one of the following contexts:
 <pre>
 (S (PREMOD ...) (NP-SBJ (-NONE- *T*)) ... )
 </pre>
 or
 <pre>
 (S (PREMOD ...) (NP-SBJ (NPB (-NONE- *T*))) ... )
 </pre>
 where <tt>(PREMOD ...)</tt> represents zero or more premodifying phrases
 and where <tt>NPB</tt> represents a node inserted by a method such as
 <a href="../../../danbikel/parser/lang/AbstractTraining.html#addBaseNPs(danbikel.lisp.Sexp)"><code>addBaseNPs(Sexp)</code></a>.  Note that the subtree rooted by <tt>NPB</tt>
 satisfies the condition of being a subtree that is the result of a
 series of unary productions (one of them, in this case) ending
 in a null element preterminal.  (This seemingly over-complicated condition
 is necessary for this method to run properly after <code>tree</code>
 has been processed by <a href="../../../danbikel/parser/lang/AbstractTraining.html#addBaseNPs(danbikel.lisp.Sexp)"><code>addBaseNPs(Sexp)</code></a>.)
 <p>
 If a subclass of this class in a language package requires more
 extensive or different checking for the &quot;subjectlessness&quot; of a
 sentence, this method should be overridden.
 <p></div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../../danbikel/parser/Training.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)">relabelSubjectlessSentences</a></code>&nbsp;in interface&nbsp;<code><a href="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>tree</code> - the parse tree in which to relabel subjectless sentences</dd>
<dt><span class="strong">Returns:</span></dt><dd>the same <code>tree</code> that was passed in, with
 subjectless sentence nodes relabeled</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../../danbikel/parser/Treebank.html#isSentence(danbikel.lisp.Symbol)"><code>Treebank.isSentence(Symbol)</code></a>, 
<a href="../../../danbikel/parser/Treebank.html#subjectAugmentation()"><code>Treebank.subjectAugmentation()</code></a>, 
<a href="../../../danbikel/parser/Treebank.html#isNullElementPreterminal(danbikel.lisp.Sexp)"><code>Treebank.isNullElementPreterminal(Sexp)</code></a>, 
<a href="../../../danbikel/parser/Treebank.html#subjectlessSentenceLabel()"><code>Treebank.subjectlessSentenceLabel()</code></a></dd></dl>
</li>
</ul>
<a name="unaryProductionsToNull(danbikel.lisp.Sexp)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>unaryProductionsToNull</h4>
<pre>protected final&nbsp;boolean&nbsp;unaryProductionsToNull(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</pre>
<div class="block">Returns whether the specified subtree consists solely of unary productions
 going to a null element terminal.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>tree</code> - the subtree to test</dd>
<dt><span class="strong">Returns:</span></dt><dd>whether the specified subtree consists solely of unary productions
         going to a null element terminal.</dd></dl>
</li>
</ul>
<a name="stripAugmentations(danbikel.lisp.Sexp)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>stripAugmentations</h4>
<pre>public&nbsp;<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;stripAugmentations(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</pre>
<div class="block">Strips any augmentations off all of the nonterminal labels of
 <code>tree</code>.  The set of nonterminal labels does <i>not</i> include
 preterminals, which are typically parts of speech.  If a particular
 language's Treebank augments preterminals, this method should be
 overridden in a language package's subclass. The only augmentations that
 will not be removed are those that are added by <a href="../../../danbikel/parser/lang/AbstractTraining.html#identifyArguments(danbikel.lisp.Sexp)"><code>identifyArguments(Sexp)</code></a>, so as to preserve the transformations of that
 method.  This method should only be called subsequent to the invocations
 of methods that require augmentations, such as <a href="../../../danbikel/parser/lang/AbstractTraining.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)"><code>relabelSubjectlessSentences(Sexp)</code></a>.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../../danbikel/parser/Training.html#stripAugmentations(danbikel.lisp.Sexp)">stripAugmentations</a></code>&nbsp;in interface&nbsp;<code><a href="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>tree</code> - the tree all of the nonterminals of which are to be stripped
 of all augmentations except those added by <code>identifyArguments</code></dd>
<dt><span class="strong">Returns:</span></dt><dd>a reference to <code>tree</code></dd></dl>
</li>
</ul>
<a name="stripAugmentations(danbikel.lisp.Symbol)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>stripAugmentations</h4>
<pre>protected&nbsp;<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;stripAugmentations(<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label)</pre>
<div class="block">Parses the specified nonterminal label and removes all augmentations.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>label</code> - the label from which to strip all augmentations</dd>
<dt><span class="strong">Returns:</span></dt><dd>the specified label having been stripped of augmentations</dd></dl>
</li>
</ul>
<a name="stripAugmentations(danbikel.lisp.Symbol, danbikel.parser.Nonterminal, boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>stripAugmentations</h4>
<pre>protected&nbsp;void&nbsp;stripAugmentations(<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label,
                      <a href="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</a>&nbsp;nonterminal,
                      boolean&nbsp;parseLabel)</pre>
<div class="block">Fills in the specified <a href="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser"><code>Nonterminal</code></a> object with the specified
 nonterminal label but without any augmentations.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>label</code> - the label from which to strip augmentations</dd><dd><code>nonterminal</code> - the <a href="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser"><code>Nonterminal</code></a> object to use for
 storage when optionally parsing the specified label and removing
 all augmentations</dd><dd><code>parseLabel</code> - indicates whether to call
 <a href="../../../danbikel/parser/Treebank.html#parseNonterminal(danbikel.lisp.Symbol)"><code>Treebank.parseNonterminal(Symbol)</code></a>; if <tt>false</tt>, this
 method assumes that the specified <a href="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser"><code>Nonterminal</code></a> object
 already contains the results of parsing the specified nonterminal
 label (if this is not the case, then the behavior of this method
 is undefined)</dd></dl>
</li>
</ul>
<a name="raisePunctuation(danbikel.lisp.Sexp)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>raisePunctuation</h4>
<pre>public&nbsp;<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;raisePunctuation(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</pre>
<div class="block">Raises punctuation to the highest possible point in a parse tree,
 resulting in a tree where no punctuation is the first or last child of a
 non-leaf node.  One consequence is that all punctuation is removed from
 the beginning and end of the sentence.  The punctuation affected is
 defined by the implementation of the method <a href="../../../danbikel/parser/Treebank.html#isPuncToRaise(danbikel.lisp.Sexp)"><code>Treebank.isPuncToRaise(Sexp)</code></a>.
 <p>
 <b>Side effect</b>: All preterminals removed from the beginning and end
 of the sentence are stored in an internal set, which can be accessed
 via <a href="../../../danbikel/parser/lang/AbstractTraining.html#getPrunedPunctuation()"><code>getPrunedPunctuation()</code></a>.
 <p>
 Example of punctuation raising:
 <pre>
 (S (NP
      (NPB Pierre Vinken)
      (, ,)
      (ADJP 61 years old)
      (, ,))
    (VP joined (NP (NPB the board))) (. .))
 </pre>
 becomes
 <pre>
 (S (NP
      (NPB Pierre Vinken)
      (, ,)
      (ADJP 61 years old))
    (, ,)
    (VP joined (NP (NPB the board))))
 </pre>
 This method appropriately deals with the case of having multiple
 punctuation elements to be raised on the left or right side of the list of
 children for a nonterminal.  For example, in English, if this method
 were passed the tree
 <pre>
 (S
   (NP (DT The) (NN dog) (, ,) (NNP Barky) (. .) (. .) (. .))
   (VP (VB was) (ADJP (JJ stupid)))
   (. .) (. .) (. .))
 </pre>
 the result would be
 <pre>
 (S
   (NP (DT The) (NN dog) (, ,) (NNP Barky))
   (. .) (. .) (. .)
   (VP (VB was) (ADJP (JJ stupid))))
 </pre>
 <p>
 <b>Bugs</b>: In the pathological case where all the children of a node
 are punctuation to raise, this method simply emits a warning to
 <code>System.err</code> and does not attempt to raise them (which would
 cause an interior node to become a leaf).
 <p></div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../../danbikel/parser/Training.html#raisePunctuation(danbikel.lisp.Sexp)">raisePunctuation</a></code>&nbsp;in interface&nbsp;<code><a href="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>tree</code> - the parse tree to destructively modify by raising punctuation</dd>
<dt><span class="strong">Returns:</span></dt><dd>a reference to the modified <code>tree</code> object</dd></dl>
</li>
</ul>
<a name="getPrunedPunctuation()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPrunedPunctuation</h4>
<pre>public&nbsp;<a href="http://java.sun.com/javase/6/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</a>&nbsp;getPrunedPunctuation()</pre>
<div class="block">Returns the set of preterminals (<code>Sexp</code> objects) that were
 punctuation elements that were "raised away" because they were either at
 the beginning or end of a sentence.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../../danbikel/parser/Training.html#getPrunedPunctuation()">getPrunedPunctuation</a></code>&nbsp;in interface&nbsp;<code><a href="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</a></code></dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="../../../danbikel/parser/lang/AbstractTraining.html#raisePunctuation(danbikel.lisp.Sexp)"><code>raisePunctuation(Sexp)</code></a></dd></dl>
</li>
</ul>
<a name="addBaseNPs(danbikel.lisp.Sexp)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addBaseNPs</h4>
<pre>public&nbsp;<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;addBaseNPs(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</pre>
<div class="block">Adds and/or relabels base NPs, which are defined in this default
 implementation to be NPs that do not dominate other non-possessive NPs,
 where a possessive NP is defined to be an NP that itself dominates
 a possessive preterminal, as determined by the implementation of the
 method <a href="../../../danbikel/parser/Treebank.html#isPossessivePreterminal(danbikel.lisp.Sexp)"><code>Treebank.isPossessivePreterminal(Sexp)</code></a>.  If an NP
 is relabeled as a base NP but is not dominated by another NP, then
 a new NP is interposed, for the sake of consistency.  For example,
 if the specified tree is the English Treebank tree
 <pre>
 (S (NP-SBJ (DT The) (NN dog)) (VP (VBD sat)))
 </pre>
 then this method will transform it to be
 <pre>
 (S (NP-SBJ (NPB (DT The) (NN dog))) (VP (VBD sat)))
 </pre>
 Note that the <tt>SBJ</tt> augmentation is transferred to the
 enclosing NP.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../../danbikel/parser/Training.html#addBaseNPs(danbikel.lisp.Sexp)">addBaseNPs</a></code>&nbsp;in interface&nbsp;<code><a href="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>tree</code> - the parse tree in which to add and/or relabel base NPs</dd>
<dt><span class="strong">Returns:</span></dt><dd>a reference to the modified version of <code>tree</code></dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../../danbikel/parser/lang/AbstractTraining.html#hasPossessiveChild(danbikel.lisp.Sexp)"><code>hasPossessiveChild(Sexp)</code></a>, 
<a href="../../../danbikel/parser/Treebank.html#isNP(danbikel.lisp.Symbol)"><code>Treebank.isNP(Symbol)</code></a>, 
<a href="../../../danbikel/parser/Treebank.html#baseNPLabel()"><code>Treebank.baseNPLabel()</code></a>, 
<a href="../../../danbikel/parser/Treebank.html#NPLabel()"><code>Treebank.NPLabel()</code></a></dd></dl>
</li>
</ul>
<a name="repairBaseNPs(danbikel.lisp.Sexp)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>repairBaseNPs</h4>
<pre>public&nbsp;<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;repairBaseNPs(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</pre>
<div class="block">Changes the specified tree so that when the last child of an
 NPB is an S, the S gets raised to be a sibling immediately following
 the NPB.  That is, situations such as
 <pre>
 (NP
   (NPB
     (DT an)
     (NN effort)
     (S ...)))
 </pre>
 get transformed to
 <pre>
 (NP
   (NPB
     (DT an)
     (NN effort))
   (S ...))
 </pre></div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../../danbikel/parser/Training.html#repairBaseNPs(danbikel.lisp.Sexp)">repairBaseNPs</a></code>&nbsp;in interface&nbsp;<code><a href="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>tree</code> - the tree whose base NPs are to be repaired</dd>
<dt><span class="strong">Returns:</span></dt><dd>a modified version of the specified tree</dd></dl>
</li>
</ul>
<a name="repairBaseNPs(danbikel.lisp.Sexp, int, danbikel.lisp.Sexp)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>repairBaseNPs</h4>
<pre>protected&nbsp;<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;repairBaseNPs(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;grandparent,
                 int&nbsp;parentIdx,
                 <a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</pre>
<div class="block">Changes the specified tree so that when the last child of an
 NPB is an S, the S gets raised to be a sibling immediately following
 the NPB.  That is, situations such as
 <pre>
 (NP
   (NPB
     (DT an)
     (NN effort)
     (S ...)))
 </pre>
 get transformed to
 <pre>
 (NP
   (NPB
     (DT an)
     (NN effort))
   (S ...))
 </pre></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>grandparent</code> - the grandparent of the specified tree, or
 <code>null</code> if the specified tree is the root</dd><dd><code>parentIdx</code> - the index of the specified tree in the
 the specified grandparent's list of children</dd><dd><code>tree</code> - the tree in which to repair base NPs</dd></dl>
</li>
</ul>
<a name="threadNPArgAugmentations(danbikel.lisp.Sexp)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>threadNPArgAugmentations</h4>
<pre>protected&nbsp;<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;threadNPArgAugmentations(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</pre>
<div class="block">Adds any argument augmentations on an NP to its head child, continuing
 recursively until reaching a preterminal.</div>
</li>
</ul>
<a name="isTypeOfSentence(danbikel.lisp.Symbol)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isTypeOfSentence</h4>
<pre>protected&nbsp;boolean&nbsp;isTypeOfSentence(<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label)</pre>
<div class="block">A helper method used by <a href="../../../danbikel/parser/lang/AbstractTraining.html#repairBaseNPs(danbikel.lisp.Sexp,%20int,%20danbikel.lisp.Sexp)"><code>repairBaseNPs(Sexp,int,Sexp)</code></a>.
 While the default implementation here simply returns the result of
 calling <a href="../../../danbikel/parser/Treebank.html#isSentence(danbikel.lisp.Symbol)"><code>Treebank.isSentence(Symbol)</code></a> with the specified label,
 subclasses may override this method if different semantics are required
 for identifying sentences that occur as siblings of base NPs.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>label</code> - the nonterminal label to test</dd>
<dt><span class="strong">Returns:</span></dt><dd><code>true</code> if the specified nonterminal represents a
 sentence, <code>false</code> otherwise</dd></dl>
</li>
</ul>
<a name="needToAddNormalNPLevel(danbikel.lisp.Sexp, int, danbikel.lisp.Sexp)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>needToAddNormalNPLevel</h4>
<pre>protected&nbsp;boolean&nbsp;needToAddNormalNPLevel(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;grandparent,
                             int&nbsp;parentIdx,
                             <a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</pre>
<div class="block">Returns <code>true</code> if a unary NP needs to be added above the
 specified base NP.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>grandparent</code> - the parent of the &quot;parent&quot; that is a
 base NP</dd><dd><code>parentIdx</code> - the index of the child of <code>grandparent</code>
 that is the base NP (that is,
 <pre>grandparent.list().get(parentIdx) == tree</pre></dd><dd><code>tree</code> - the base NP, whose parent is <code>grandparent</code></dd></dl>
</li>
</ul>
<a name="isCoordinatedPhrase(danbikel.lisp.Sexp, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isCoordinatedPhrase</h4>
<pre>protected&nbsp;boolean&nbsp;isCoordinatedPhrase(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree,
                          int&nbsp;headIdx)</pre>
<div class="block">Returns <code>true</code> if a non-head child of the specified
 tree is a conjunction, and that conjunction is either post-head
 but non-final, or immediately pre-head but non-initial (where
 &quot;immediately pre-head&quot; means &quot;at the first index
 less than <code>headIdx</code> that is not punctuation, as determined
 by <a href="../../../danbikel/parser/Treebank.html#isPunctuation(danbikel.lisp.Symbol)"><code>Treebank.isPunctuation(Symbol)</code></a>).  A child is a
 conjunction if its label is one for which
 <a href="../../../danbikel/parser/Treebank.html#isConjunction(danbikel.lisp.Symbol)"><code>Treebank.isConjunction(Symbol)</code></a> returns <code>true</code>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>tree</code> - the (sub)tree to test</dd><dd><code>headIdx</code> - the index of the head child of the specified tree</dd></dl>
</li>
</ul>
<a name="hasPossessiveChild(danbikel.lisp.Sexp)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasPossessiveChild</h4>
<pre>protected&nbsp;boolean&nbsp;hasPossessiveChild(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</pre>
<div class="block">Returns <code>true</code> if <code>tree</code> contains a child for which
 <a href="../../../danbikel/parser/Treebank.html#isPossessivePreterminal(danbikel.lisp.Sexp)"><code>Treebank.isPossessivePreterminal(Sexp)</code></a> returns
 <code>true</code>, <code>false</code> otherwise.  This is a helper method
 used by the default implementation of <a href="../../../danbikel/parser/lang/AbstractTraining.html#addBaseNPs(danbikel.lisp.Sexp)"><code>addBaseNPs(Sexp)</code></a>.
 Possessive children are often more even-tempered than possessive parents.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>tree</code> - the parse subtree to check for possessive preterminal
 children</dd></dl>
</li>
</ul>
<a name="removeNullElements(danbikel.lisp.Sexp)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>removeNullElements</h4>
<pre>public&nbsp;<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;removeNullElements(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</pre>
<div class="block">Removes all null elements, that is, those nodes of <code>tree</code> for
 which <a href="../../../danbikel/parser/Treebank.html#isNullElementPreterminal(danbikel.lisp.Sexp)"><code>Treebank.isNullElementPreterminal(Sexp)</code></a> returns
 <code>true</code>.  Additionally, if the removal of a null element leaves
 an interior node that is childless, then this interior node is removed as
 well.  For example, if we have the following sentence in English
 <pre> (S (NP-SBJ (-NONE- *T*)) (VP ...)) </pre>
 it will be transformed to be
 <pre> (S (VP ...)) </pre>
 <b>N.B.</b>: This method should only be invoked <i>after</i> preprocessing
 with <a href="../../../danbikel/parser/lang/AbstractTraining.html#relabelSubjectlessSentences(danbikel.lisp.Sexp)"><code>relabelSubjectlessSentences(Sexp)</code></a> and <a href="../../../danbikel/parser/lang/AbstractTraining.html#addGapInformation(danbikel.lisp.Sexp)"><code>addGapInformation(Sexp)</code></a>, as these methods (and possibly others, if
 overridden) rely on the presence of null elements.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../../danbikel/parser/Training.html#removeNullElements(danbikel.lisp.Sexp)">removeNullElements</a></code>&nbsp;in interface&nbsp;<code><a href="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</a></code></dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="../../../danbikel/parser/Treebank.html#isNullElementPreterminal(danbikel.lisp.Sexp)"><code>Treebank.isNullElementPreterminal(Sexp)</code></a></dd></dl>
</li>
</ul>
<a name="startSym()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>startSym</h4>
<pre>public&nbsp;<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;startSym()</pre>
<div class="block">Returns the symbol to indicate hidden nonterminals that precede the first
 in a sequence of modifier nonterminals.  The default value is the return
 value of <code>Symbol.add(&quot;+START+&quot;)</code>; if this value
 conflicts with an actual nonterminal in a particular Treebank, then this
 method should be overridden.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../../danbikel/parser/Training.html#startSym()">startSym</a></code>&nbsp;in interface&nbsp;<code><a href="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</a></code></dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="../../../danbikel/parser/Trainer.html" title="class in danbikel.parser"><code>Trainer</code></a></dd></dl>
</li>
</ul>
<a name="startWord()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>startWord</h4>
<pre>public&nbsp;<a href="../../../danbikel/parser/Word.html" title="class in danbikel.parser">Word</a>&nbsp;startWord()</pre>
<div class="block">Returns the <code>Word</code> object that represents the hidden "head
 word" of the start symbol.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../../danbikel/parser/Training.html#startWord()">startWord</a></code>&nbsp;in interface&nbsp;<code><a href="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</a></code></dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="../../../danbikel/parser/lang/AbstractTraining.html#startSym"><code>startSym</code></a>, 
<a href="../../../danbikel/parser/Trainer.html" title="class in danbikel.parser"><code>Trainer</code></a></dd></dl>
</li>
</ul>
<a name="stopSym()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>stopSym</h4>
<pre>public&nbsp;<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;stopSym()</pre>
<div class="block">Returns the symbol to indicate a hidden nonterminal that follows the last
 in a sequence of modifier nonterminals.  The default value is the return
 value of <code>Symbol.add(&quot;+STOP+&quot;)</code>; if this value
 conflicts with an actual nonterminal in a particular Treebank, then this
 method should be overridden.
 <p>
 This symbol may also be used as a special value that is guaranteed not
 to conflict with any nonterminal in a given language's treebank.
 <p></div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../../danbikel/parser/Training.html#stopSym()">stopSym</a></code>&nbsp;in interface&nbsp;<code><a href="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</a></code></dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="../../../danbikel/parser/Trainer.html" title="class in danbikel.parser"><code>Trainer</code></a></dd></dl>
</li>
</ul>
<a name="stopWord()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>stopWord</h4>
<pre>public&nbsp;<a href="../../../danbikel/parser/Word.html" title="class in danbikel.parser">Word</a>&nbsp;stopWord()</pre>
<div class="block">Returns the <code>Word</code> object that represents the hidden "head
 word" of the stop symbol.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../../danbikel/parser/Training.html#stopWord()">stopWord</a></code>&nbsp;in interface&nbsp;<code><a href="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</a></code></dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="../../../danbikel/parser/lang/AbstractTraining.html#stopSym"><code>stopSym</code></a>, 
<a href="../../../danbikel/parser/Trainer.html" title="class in danbikel.parser"><code>Trainer</code></a></dd></dl>
</li>
</ul>
<a name="topSym()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>topSym</h4>
<pre>public&nbsp;<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;topSym()</pre>
<div class="block">Returns the symbol to indicate the hidden root of all parse trees.  The
 default value is the return value of
 <code>Symbol.add(&quot;+TOP+&quot;)</code>; if this value conflicts with
 an actual nonterminal in a particular Treebank, then this method should be
 overridden.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../../danbikel/parser/Training.html#topSym()">topSym</a></code>&nbsp;in interface&nbsp;<code><a href="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</a></code></dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="../../../danbikel/parser/Trainer.html" title="class in danbikel.parser"><code>Trainer</code></a></dd></dl>
</li>
</ul>
<a name="topWord()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>topWord</h4>
<pre>public&nbsp;<a href="../../../danbikel/parser/Word.html" title="class in danbikel.parser">Word</a>&nbsp;topWord()</pre>
<div class="block">Returns the <code>Word</code> object that represents the hidden "head
 word" of the hidden root of all parse trees.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../../danbikel/parser/Training.html#topWord()">topWord</a></code>&nbsp;in interface&nbsp;<code><a href="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</a></code></dd>
</dl>
</li>
</ul>
<a name="headSym()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>headSym</h4>
<pre>public&nbsp;<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;headSym()</pre>
<div class="block">Returns the symbol used in the <a href="../../../danbikel/parser/lang/AbstractTraining.html#argContexts"><code>argContexts</code></a> map to identify
 an offset from the head child.</div>
</li>
</ul>
<a name="headPreSym()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>headPreSym</h4>
<pre>public&nbsp;<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;headPreSym()</pre>
<div class="block">The symbol that is a possible mapping <a href="../../../danbikel/parser/lang/AbstractTraining.html#argContexts"><code>argContexts</code></a> to indicate
 to choose a child relative to the left side of the head as an argument.
 For example, an argument context might be <code>VP</code> mapping to
 <code>(head-left left MD VBD)</code>, meaning that the children to the left
 of the head child should be searched from left to right, and the first
 child found that is a member of the set <tt>{MD, VBD}</tt> should be
 considered a possible argument of the head.</div>
</li>
</ul>
<a name="headPostSym()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>headPostSym</h4>
<pre>public&nbsp;<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;headPostSym()</pre>
<div class="block">The symbol that is a possible mapping <a href="../../../danbikel/parser/lang/AbstractTraining.html#argContexts"><code>argContexts</code></a> to indicate to
 choose a child relative to the right side of the head as an argument. For
 example, an argument context might be <code>PP</code> mapping to
 <code>(head-right left PP NP WHNP ADJP)</code>, meaning that the children
 to the right of the head child should be searched from left to right, and
 the first child found that is a member of the set <tt>{PP, NP, WHNP,
 ADJP}</tt> should be considered a possible argument of the head.</div>
</li>
</ul>
<a name="createArgAugmentationsList()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createArgAugmentationsList</h4>
<pre>protected&nbsp;void&nbsp;createArgAugmentationsList()</pre>
<div class="block">A helper method that runs through every nonterminal "pattern" for each
 context in <a href="../../../danbikel/parser/lang/AbstractTraining.html#argContexts"><code>argContexts</code></a>, parses the pattern using <a href="../../../danbikel/parser/Treebank.html#parseNonterminal(danbikel.lisp.Symbol)"><code>Treebank.parseNonterminal(danbikel.lisp.Symbol)</code></a>, runs through the resulting list of
 augmentations and adds each augmentation symbol to the <a href="../../../danbikel/parser/lang/AbstractTraining.html#argAugmentations"><code>argAugmentations</code></a> list.</div>
</li>
</ul>
<a name="createArgNonterminalsSet()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createArgNonterminalsSet</h4>
<pre>protected&nbsp;void&nbsp;createArgNonterminalsSet()</pre>
<div class="block">Sets the <a href="../../../danbikel/parser/lang/AbstractTraining.html#argNonterminals"><code>argNonterminals</code></a> data member to be the static set
 of argument nonterminals.  The default implementation here scans the
 <a href="../../../danbikel/parser/lang/AbstractTraining.html#argContexts"><code>argContexts</code></a> list, and adds every nonterminal "pattern" for a
 given context to the set.  If the nonterminal to be added is not
 already an argument as determined by <a href="../../../danbikel/parser/lang/AbstractTraining.html#isArgument(danbikel.lisp.Symbol)"><code>isArgument(danbikel.lisp.Symbol)</code></a>, then the
 <a href="../../../danbikel/parser/Treebank.html#canonicalAugDelimiter()"><code>Treebank.canonicalAugDelimiter()</code></a> and <a href="../../../danbikel/parser/lang/AbstractTraining.html#defaultArgAugmentation"><code>defaultArgAugmentation</code></a>
 are appended before it is added to the set. This default implementation,
 therefore, does not necessarily return a complete set of all possible arg
 nonterminals, but merely those that are explicitly named in the
 argument-finding contexts. As this method is primarily intended to be
 used by <a href="../../../danbikel/parser/SubcatBag.html" title="class in danbikel.parser"><code>SubcatBag</code></a> when setting up its static resources for
 categorizing argument nonterminals, this implementation is sufficient,
 as all nonterminals that are not explicitly named will be thrown into
 the miscellaneous category.</div>
</li>
</ul>
<a name="argNonterminals()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>argNonterminals</h4>
<pre>public&nbsp;<a href="http://java.sun.com/javase/6/docs/api/java/util/Set.html?is-external=true" title="class or interface in java.util">Set</a>&nbsp;argNonterminals()</pre>
<div class="block">Returns a static set of possible argument nonterminals.  The default
 implementation here invokes <a href="../../../danbikel/parser/lang/AbstractTraining.html#createArgNonterminalsSet()"><code>createArgNonterminalsSet()</code></a> if
 the <a href="../../../danbikel/parser/lang/AbstractTraining.html#argNonterminals"><code>argNonterminals</code></a> data member has not been initialized
 (that is, if it is <code>null</code>).</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../../danbikel/parser/Training.html#argNonterminals()">argNonterminals</a></code>&nbsp;in interface&nbsp;<code><a href="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</a></code></dd>
<dt><span class="strong">Returns:</span></dt><dd>a static set of possible argument nonterminals</dd></dl>
</li>
</ul>
<a name="removeArgAugmentation(danbikel.lisp.Symbol)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>removeArgAugmentation</h4>
<pre>public&nbsp;<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;removeArgAugmentation(<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label)</pre>
<div class="block"><strong>Description copied from interface:&nbsp;<code><a href="../../../danbikel/parser/Training.html#removeArgAugmentation(danbikel.lisp.Symbol)">Training</a></code></strong></div>
<div class="block">Removes any argument augmentations from the specified nonterminal label.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../../danbikel/parser/Training.html#removeArgAugmentation(danbikel.lisp.Symbol)">removeArgAugmentation</a></code>&nbsp;in interface&nbsp;<code><a href="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>label</code> - the label whose argument augmentations are to be removed</dd>
<dt><span class="strong">Returns:</span></dt><dd>a new label with no argument augmentations</dd></dl>
</li>
</ul>
<a name="removeArgAugmentation(danbikel.lisp.Symbol, danbikel.parser.Nonterminal)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>removeArgAugmentation</h4>
<pre>protected&nbsp;<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;removeArgAugmentation(<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;label,
                           <a href="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser">Nonterminal</a>&nbsp;nonterminal)</pre>
<div class="block">Parses label into the specified <a href="../../../danbikel/parser/Nonterminal.html" title="class in danbikel.parser"><code>Nonterminal</code></a> object and then
 removes all argument augmentations.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>label</code> - the label from which to remove argument augmentations</dd><dd><code>nonterminal</code> - the object to use as temporary storage during
 execution of this method</dd>
<dt><span class="strong">Returns:</span></dt><dd>the symbol that is the specified label removed of its
 argument augmentations</dd></dl>
</li>
</ul>
<a name="removeGapAugmentation(danbikel.lisp.Sexp)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>removeGapAugmentation</h4>
<pre>public&nbsp;<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;removeGapAugmentation(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;sexp)</pre>
<div class="block">If the specified S-expression is a list, this method modifies the
 list to contain only symbols without gap augmentations;
 otherwise, this method removes the gap augmentation (if one exists)
 in the specified symbol and returns that new symbol.  Note that
 the presence of gap augmentations is determined by matching for
 <a href="../../../danbikel/parser/lang/AbstractTraining.html#delimAndGapStr"><code>delimAndGapStr</code></a>, which means that symbols consisting solely
 of the gap augmentation itself (<a href="../../../danbikel/parser/lang/AbstractTraining.html#gapAugmentation"><code>gapAugmentation</code></a>) will
 be unaffected.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../../danbikel/parser/Training.html#removeGapAugmentation(danbikel.lisp.Sexp)">removeGapAugmentation</a></code>&nbsp;in interface&nbsp;<code><a href="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>sexp</code> - a symbol or list of symbols from which to remvoe any
 gap augmentations</dd>
<dt><span class="strong">Returns:</span></dt><dd>a symbol or list of symbols with no gap augmentations</dd></dl>
</li>
</ul>
<a name="postProcess(danbikel.lisp.Sexp)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>postProcess</h4>
<pre>public&nbsp;void&nbsp;postProcess(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</pre>
<div class="block"><strong>Description copied from interface:&nbsp;<code><a href="../../../danbikel/parser/Training.html#postProcess(danbikel.lisp.Sexp)">Training</a></code></strong></div>
<div class="block">Post-processes a parse tree after decoding, eseentially undoing
 the steps performed in <a href="../../../danbikel/parser/Training.html#preProcess(danbikel.lisp.Sexp)">preprocessing</a>.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../../danbikel/parser/Training.html#postProcess(danbikel.lisp.Sexp)">postProcess</a></code>&nbsp;in interface&nbsp;<code><a href="../../../danbikel/parser/Training.html" title="interface in danbikel.parser">Training</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>tree</code> - the tree to be post-processed</dd></dl>
</li>
</ul>
<a name="removeOnlyChildBaseNPs(danbikel.lisp.Sexp)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>removeOnlyChildBaseNPs</h4>
<pre>protected&nbsp;void&nbsp;removeOnlyChildBaseNPs(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</pre>
<div class="block">Handle case where an NP dominates a base NP and has no other children
 (the base NP is an "only child" of the dominating NP).  This method
 will effectively remove the base NP node, hooking up all its children
 as the children of the parent NP.</div>
</li>
</ul>
<a name="canonicalizeNonterminals(danbikel.lisp.Sexp)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>canonicalizeNonterminals</h4>
<pre>protected&nbsp;void&nbsp;canonicalizeNonterminals(<a href="../../../danbikel/lisp/Sexp.html" title="class in danbikel.lisp">Sexp</a>&nbsp;tree)</pre>
<div class="block">Modifies each nonterminal in the specified tree to be its canonical
 version.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>tree</code> - the tree whose nonterminals are to be converted to their
 canonical versions</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../../danbikel/parser/Treebank.html#getCanonical(danbikel.lisp.Symbol)"><code>Treebank.getCanonical(Symbol)</code></a></dd></dl>
</li>
</ul>
<a name="main(java.lang.String[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>main</h4>
<pre>public static&nbsp;void&nbsp;main(<a href="http://java.sun.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>[]&nbsp;args)</pre>
<div class="block">Test driver for this class.  Currently, this method reads in a file
 containing parse trees, invokes the <a href="../../../danbikel/parser/lang/AbstractTraining.html#preProcess(danbikel.lisp.Sexp)"><code>preProcess(Sexp)</code></a> method on
 them, and then outputs the resulting trees to standard out.
 Usage: &lt;filename&gt;, where &lt;filename&gt; contains S-expressions
 representing trees.</div>
</li>
</ul>
<a name="readMetadataHook(danbikel.lisp.Symbol, int, danbikel.lisp.SexpList)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>readMetadataHook</h4>
<pre>protected&nbsp;void&nbsp;readMetadataHook(<a href="../../../danbikel/lisp/Symbol.html" title="class in danbikel.lisp">Symbol</a>&nbsp;dataType,
                    int&nbsp;metadataLen,
                    <a href="../../../danbikel/lisp/SexpList.html" title="class in danbikel.lisp">SexpList</a>&nbsp;metadata)</pre>
<div class="block">A hook for subclasses to have their own custom metadata types.
 The default version here does nothing.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>dataType</code> - the symbol representing the data type for this
 metadata entry</dd><dd><code>metadataLen</code> - the length of the list of the specified
 metadata entry</dd><dd><code>metadata</code> - the list of a metadata entry to be processed
 by a subclass, if the data type is recognized</dd></dl>
</li>
</ul>
<a name="readMetadata(danbikel.lisp.SexpTokenizer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>readMetadata</h4>
<pre>protected&nbsp;void&nbsp;readMetadata(<a href="../../../danbikel/lisp/SexpTokenizer.html" title="class in danbikel.lisp">SexpTokenizer</a>&nbsp;metadataTok)
                     throws <a href="http://java.sun.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</a></pre>
<div class="block">Reads metadata to fill in <a href="../../../danbikel/parser/lang/AbstractTraining.html#argContexts"><code>argContexts</code></a> and
 <a href="../../../danbikel/parser/lang/AbstractTraining.html#semTagArgStopSet"><code>semTagArgStopSet</code></a>.  Does no format
 checking on the S-expressions of the metadata resource.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>metadataTok</code> - tokenizer for stream of S-expressions containing
 metadata for this class</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code><a href="http://java.sun.com/javase/6/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</a></code></dd></dl>
</li>
</ul>
<a name="printMetadata()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>printMetadata</h4>
<pre>public&nbsp;void&nbsp;printMetadata()</pre>
<div class="block">Debugging method to print the metadata used by this class.</div>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/AbstractTraining.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
<div class="aboutLanguage"><em>Parsing Engine</em></div>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../danbikel/parser/lang/AbstractHeadFinder.HeadFindInstruction.html" title="class in danbikel.parser.lang"><span class="strong">Prev Class</span></a></li>
<li><a href="../../../danbikel/parser/lang/AbstractTreebank.html" title="class in danbikel.parser.lang"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?danbikel/parser/lang/AbstractTraining.html" target="_top">Frames</a></li>
<li><a href="AbstractTraining.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small>Author: <a href="http://www.cis.upenn.edu/~dbikel/">Dan Bikel.</a></small></p>
</body>
</html>
