package danbikel.util;

/**
 * Provides a cache that makes least-recently used items available for
 * garbage collection.  <code>LRUCache</code> objects maintain an
 * internal data structure, storing a certain number of the cache keys
 * using strong references; the number of such items is called the
 * <i>minimum capacity</i> of the cache, and is specifiable at
 * construction time.  When the minimum capacity is exceeded, the
 * least-recently used key is removed from this data structure of
 * strong references, and the key will only be cached using a weak
 * reference, thus making it available for garbage collection.
 */
public class LRUCache extends WeakHashMap {
  // inner class for linked list nodes
  private static class Node {
    Object element;
    Node next;
    
    Node(Object element, Node next) {
      this.element = element;
      this.next = next;
    }
  }

  // data members
  /**
   * Head of the circular linked list that holds strong keys in order
   * of usage.
   */
  private Node head;
  /** Map of strong keys to <code>Node</code> objects in LRU list. */
  private HashMap strongKeys;
  /**
   * Number of items in this cache that will not be garbage collected:
   * once this cache grows to have at least this number of items, it can never
   * shrink to have fewer items.  This property is achieved by maintaining
   * an internal structure to store up to <code>minCapacity</code> with
   * strong references.
   */
  private int minCapacity;
  /** Used by {@link #makeMostRecentlyUsed}. */
  private Object mostRecentValue;
  /** Used by {@link #makeMostRecentlyUsed}. */
  private Object mostRecentPutRetVal;


  // constructors

  /**
   * Constructs an <code>LRUCache</code> where the most-recently used
   * <code>minCapacity</code> elements are guaranteed not to be
   * garbage collected.  The underlying <code>WeakHashMap</code> will
   * be constructed with the default initial capacity and the default
   * load factor.
   *
   * @param minCapacity the minimum number of elements held by this cache
   */
  public LRUCache(int minCapacity) {
    super();
    construct(minCapacity);
  }

  /**
   * Constructs an <code>LRUCache</code> where the most-recently used
   * <code>minCapacity</code> elements are guaranteed not to be
   * garbage collected.  The underlying <code>WeakHashMap</code> will
   * be constructed with the specified initial capacity and the
   * default load factor.
   *
   * @param minCapacity the minimum number of elements held by this cache
   * @param initialCapacity the initial capacity of the underlying
   * <code>WeakHashMap</code>
   */
  public LRUCache(int minCapacity, int initialCapacity) {
    super(initialCapacity);
    construct(minCapacity);
  }

  /**
   * Constructs an <code>LRUCache</code> where the most-recently used
   * <code>minCapacity</code> elements are guaranteed not to be
   * garbage collected.  The underlying <code>WeakHashMap</code> will
   * be constructed with the specified initial capacity and the
   * specified load factor.
   *
   * @param minCapacity the minimum number of elements held by this cache
   * @param initialCapacity the initial capacity of the underlying
   * <code>WeakHashMap</code>
   * @param loadFactor the load factor of the underlying
   * <code>WeakHashMap</code>
   */
  public LRUCache(int minCapacity, int initialCapacity, float loadFactor) {
    super(initialCapacity, loadFactor);
    construct(minCapacity);
  }

  private void construct(int minCapacity) {
    this.minCapacity = minCapacity;
    strongKeys = new HashMap(minCapacity);
    head = new Node(null, null);
    head.next = head;
  }

  /**
   * Associates the specified key with the specified value in this cache.
   * The specified key is considered to be the most-recently used key of this
   * cache, and the internal data structure containing strong references
   * is updated accordingly.
   *
   * @param key the key to put into this cache with the specified value
   * @param value the value to associate with the specified key in this cache
   * @return the old value associated with <code>key</code>, or
   * <code>null</code> if there was no mapping for this key
   */
  public Object put(Object key, Object value) {
    synchronized (strongKeys) {
      boolean putWasDone = makeMostRecentlyUsed(key, true, value);
      return (putWasDone ? mostRecentPutRetVal : super.put(key, value));
    }
  }

  /**
   * Gets the value associated in this cache with the specified key.
   * The specified key is considered to be the most-recently used key of this
   * cache, and the internal data structure containing strong references
   * is updated accordingly.
   *
   * @param key the key whose value is to be retrieved from this cache
   * @return the value associated with the specified key, or <code>null</code>
   * if the key is not in this cache
   */
  public Object get(Object key) {
    synchronized (strongKeys) {
      if (this.containsKey(key)) {
	makeMostRecentlyUsed(key, false, null);
	return mostRecentValue;
      }
      else
	return null;
    }
  }

  /**
   * Makes the specified key the most recently used one in the internal
   * linked list.  Note that this method is guaranteed to set mostRecentValue
   * to the most current value for the specified key.
   *
   * @param key the key to make the most recently used
   * @param needToPutValue if <code>true</code>, then the if the specified
   * key is not in the strong keys but *is* in the cache, then this parameter
   * should be used when doing a super.put method call
   * @param putVale the value to put for the specified key if the specified
   * key is not in the strong keys but *is* in the cache (in which case
   * we do a crazy remove-and-then-re-add operation, to ensure that we
   * have a handle onto the same key object as is in the WeakHashMap)
   */
  private final boolean makeMostRecentlyUsed(Object key,
					     boolean needToPutValue,
					     Object putValue) {
    boolean putWasDone = false;

    // if key is among strong references, remove it
    Node oldKeyNode = (Node)strongKeys.get(key);
    boolean inStrongKeys = oldKeyNode != null;
    if (inStrongKeys) {
      // we need to grab hold of the key as it exists in the strong
      // keys list, in case the specified key is equal to this key but
      // is not the exact same object (since the underlying WeakHashMap
      // will keep an existing key when put(key, value) is called with
      // a key that is equal via equals method but not same object);
      // note that if WeakHashMap changes this behavior, this will need
      // to be changed!!!
      key  = oldKeyNode.element; 
      remove(oldKeyNode);
    }
    else if (strongKeys.size() == minCapacity) // if strong keys are maxed out,
      removeFirst();                      // remove least-recently used element

    Object currValue = super.get(key);
    mostRecentValue = currValue;
    boolean containsKey = currValue != null;
    if (!inStrongKeys && containsKey) {
      // remove and then re-add element with current key, to be sure
      // that we store a strong reference to exactly the same object
      // as is stored in WeakHashMap (this is a more expensive
      // operation than we'd like, but until we implement our own
      // WeakHashMap, with direct access to key objects, this is the
      // best thing to do)
      Object value = needToPutValue ? putValue : currValue;
      mostRecentValue = value;
      super.remove(key);
      mostRecentPutRetVal = super.put(key, value);
      putWasDone = true;
    }

    addLast(key); // last element is most-recently used

    return putWasDone;
  }

  /**
   * Removes the specified key from this cache.
   * @param key the key to remove from this cache
   * @return the value of the cached key in this cache, or <code>null</code>
   * if this cache did not containg <code>key</code>
   */
  public Object remove(Object key) {
    synchronized (strongKeys) {
      if (strongKeys.containsKey(key))
	remove((Node)strongKeys.get(key));
      return super.remove(key);
    }
  }

  private final void removeFirst() {
    remove(head.next);
  }

  /**
   * Remove the specified node in the linked list.
   */
  private final void remove(Node node) {
    if (strongKeys.size() == 0 || node == head) {
      return;
    }
    else {
      // first, grab data at specified node
      Object removedElement = node.element;

      // make specified node become the node after it
      Node nextNode = node.next;
      node.element = nextNode.element;
      node.next = nextNode.next;
      if (nextNode == head)
	head = node;

      // keep strongKeys map up to date
      strongKeys.remove(removedElement);
      if (node != head)
	strongKeys.put(node.element, node);
    }
  }

  private final void addLast(Object element) {
    addBefore(head, element);
  }

  /**
   * Adds a new node containing the specified element before the specified
   * existing node.
   */
  private final void addBefore(Node node, Object element) {
    // make specified node become a "new" node with specified element;
    // make its next node be a copy of the specified old node
    Node oldNode = new Node(node.element, node.next);
    node.element = element;
    node.next = oldNode;
    if (node == head)
      head = oldNode;

    // keep strongKeys map up to date
    if (oldNode != head)
      strongKeys.put(oldNode.element, oldNode);
    strongKeys.put(node.element, node);
  }

  /**
   * Returns a string representation of the subset of key-value pairs of
   * this cache for which strong references are used for the keys.
   * This method is intended to be used for debugging.
   */
  public final String listToString() {
    synchronized (strongKeys) {
      StringBuffer sb = new StringBuffer();
      sb.append("{");
      Node curr = head.next;
      for (; curr != head; curr = curr.next) {
	sb.append(curr.element).append("=").append(super.get(curr.element));
	if (curr.next != head)
	  sb.append(", ");
      }
      sb.append("}");
      return sb.toString();
    }
  }
}
