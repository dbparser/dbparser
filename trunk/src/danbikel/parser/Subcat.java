package danbikel.parser;

import danbikel.lisp.*;
import java.util.*;

/**
 * Specification for a collection of required arguments to be
 * generated by a parser, also known as a subcategorization frame.  In
 * the parsing models supported by this package, a subcategorization
 * frame, or simply <i>subcat</i>, has a slightly modified semantics,
 * more general in one sense, more specific in another: it is the
 * collection of requirements on a particular side of a head child of
 * some parent nonterminal that have yet to be met, where a
 * requirement is typically an argument nonterminal to be generated,
 * but may also include other elements generated by the parser, such
 * as traces (gaps).  Thus, the subcats specified by this interface
 * are dynamic, in that they start off with a full set of requirements
 * that gets diminished as parsing proceeds.
 * <p>
 * Implementations of this interface may choose the manner in which
 * these requirements are met via their implementations of the
 * <code>add</code> and <code>remove</code> methods.  For example, a
 * very simple implementation might simply increment an internal
 * counter for every call to <code>add</code>, decrementing this
 * counter for every call to <code>remove</code>, causing the
 * semantics for subcat frames to be simply a requirement on the
 * <i>number</i> of modifying nonterminals generated, regardless of
 * their labels.  A more sophisticated implementation might insist on
 * generating all arguments in the order in which they were added to
 * this subcat frame.  In general, no implementation should require more
 * calls to <code>remove</code> than the number of requirements added
 * via invocations of <code>add</code> and <code>addAll</code>.
 * <p>
 * At minimum, all implementing classes should have a no-argument
 * default constructor and a one-argument constructor that accepts a
 * <code>SexpList</code> containing only <code>Symbol</code> objects,
 * to be passed to the {@link #addAll(SexpList)} method.
 *
 * @see Subcats
 */
public interface Subcat extends MutableEvent, SexpConvertible {

  /**
   * Adds the specified nonterminal to the required arguments of this
   * subcat frame.  Implementors should check whether the specified requirement
   * is valid and may choose not to add the specified
   * requirement if it is not.  Validity of a requirement is determined
   * by the implementor; a typical notion of validity is that the requirement
   * must either be a complex nonterminal with the argument augmentation
   * (as determined by {@link Training#isArgumentFast(Symbol)}) or be
   * the gap augmentation symbol.
   *
   * @param requirement the requirement to add to this subcat frame (typically
   * an argument nonterminal)
   * @return this <code>Subcat</code> object
   *
   * @see Training#defaultArgAugmentation()
   * @see Training#gapAugmentation()
   * @see Training#isArgumentFast(Symbol)
   */
  public Subcat add(Symbol requirement);

  /**
   * Adds the specified list of nonterminals (symbols) to the required arguments
   * of this subcat frame.
   *
   * @param list the list of requirements to be added to this subcat frame
   * @return whether this subcat was modified
   */
  public boolean addAll(SexpList list);

  /**
   * Attempt to remove the specified symbol from the set of requirements
   * in this subcat frame.  It is an error to call this method after
   * {@link #empty} returns <code>true</code>.
   *
   * @param requirement the element that has been generated by the parser
   * and is thus a candidate for removal from this subcat
   * @return <code>true</code> if the specified requirement can be removed
   * from this subcat
   *
   * @see #contains(Symbol)
   */
  public boolean remove(Symbol requirement);

  /**
   * Returns the number of required arguments contained in this subcat frame.
   *
   * @return the number of required arguments contained in this subcat frame
   */
  public int size();

  /**
   * Returns <code>true</code> if all requirements of this subcat frame have
   * been met.  This method should return <code>true</code> if and only if
   * <code>size()&nbsp;==&nbsp;0</code>.
   *
   * @return whether all requirements of this subcat frame have been met
   */
  public boolean empty();

  /**
   * Returns <code>true</code> if this subcat frame contains the
   * specified requirement.
   *
   * @param requirement the requirement for which membership in this
   * subcat is to be checked
   * @return <code>true</code> if this subcat contains <code>requirement</code>,
   * that is, returns <code>true</code> if and only if {@link #remove(Symbol)}
   * would remove the specified symbol from this subcat
   */
  public boolean contains(Symbol requirement);


  /**
   * Returns an iterator over the requirements contained in this subcat frame.
   * Iterators are only required to return elements in the order in which
   * they were added if the subcat implementation considers order relevant
   * to equality.
   *
   * @return an iterator over the requirements contained in this subcat frame
   */
  public Iterator iterator();

  /**
   * Returns a hash code of this object.
   */
  public int hashCode();

  /**
   * Compares the specified object with this subcat frame for
   * equality.  This method should return <code>true</code> if and
   * only if the specified object is the same run-time type as this
   * object and contains identical requirements in an identical order,
   * if order is relevant to the implementation of this interface.
   */
  public boolean equals(Object obj);

  /**
   * Returns a canonical instance of this object using the specified map
   * (optional operation).
   *
   * @param map the reflexive map to use for canonicalization: the key-value
   * pair of (<code>this,&nbsp;this</code>) should be added to <code>map</code>
   * if this object is not already a key in <code>map</code>
   * @param copyInto specifies whether to copy this subcat before inserting
   * into the canonical map
   * @return a canonical instance of this object
   */
  public Subcat getCanonical(boolean copyInto, Map<Subcat, Subcat> map);

  /**
   * Returns a list view of the information contained in this subcat,
   * such that an equivalent subcat would result if a new
   * <code>Subcat</code> object of this run-time type were constructed
   * and its {@link #addAll(SexpList)} method were invoked with the
   * list returned by this method.
   */
  public Sexp toSexp();

  /**
   * Causes this subcat to be equal to the specified subcat by copying the
   * specified subcat's data to this subcat.
   *
   * @param other the subcat that this subcat is to become
   * 
   * @throws ClassCastException if the specified subcat is not of the same
   * run-time type as this subcat
   */
  public void become(Subcat other);
}
